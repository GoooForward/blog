<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为Fluid新增相册功能</title>
    <link href="/blog/2024/09/02/study/%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%A2%9E%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/blog/2024/09/02/study/%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%A2%9E%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>很久没写过博客了，是的，摆烂了很久，以至于我重新打开这个博客时，已经忘记了当时是如何实现的这个相册功能，所以如今就将这个流程记录一遍。</p><h1 id="0x01-部署流程"><a href="#0x01-部署流程" class="headerlink" title="0x01 部署流程"></a>0x01 部署流程</h1><p>由于我不懂JavaScript和前端，所以这个部署过程的原理我并没有搞清楚，这里只是记录流程</p><p>参考的是这篇<a href="https://weichao.io/09dacc5ba02c/#fn:5">博客</a></p><h2 id="1-创建相册的页面"><a href="#1-创建相册的页面" class="headerlink" title="-1- 创建相册的页面"></a>-1- 创建相册的页面</h2><p>在项目blog文件夹下执行 Hexo 命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo new page &quot;photo&quot;<br></code></pre></td></tr></table></figure><p>Hexo会自动创建 <code>source/photo</code>，里面有一个文件 <code>index.md</code>。</p><p>这个<code>index.md</code>就是此描述了该页面的内容，其内容如下（注释由GLM AI生成）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section"># 页面配置信息</span><br>title: 摄影 # 页面的标题<br>subtitle: &#x27;&#x27; # 页面的副标题，留空则不显示<br>excerpt: &#x27;&#x27; # 页面的摘要或简短描述，留空则不显示<br>banner<span class="hljs-emphasis">_img: /img/cover.jpg # 页面的横幅图片路径</span><br><span class="hljs-emphasis">lazyload: true # 图片是否启用懒加载，true为启用</span><br><span class="hljs-emphasis">hide: false # 是否隐藏该页面，false为不隐藏</span><br><span class="hljs-emphasis">date: 2023-12-01 19:04:03 # 页面的创建或更新日期</span><br><span class="hljs-emphasis">layout: photo # 页面的布局类型，此处为专门为照片设计的布局</span><br><span class="hljs-emphasis">index_</span>img: # 索引图片，用于在列表中展示的缩略图，留空则不显示<br>tags: # 页面的标签，用于分类和搜索，留空则不指定<br>categories: # 页面的分类，用于组织内容，留空则不指定<br><span class="hljs-section">updated: # 页面的更新日期，留空则不指定</span><br><span class="hljs-section">---</span><br><br><span class="hljs-section"># CSS样式定义</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br>  /* 图片网格容器样式 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  .ImageGrid &#123;</span><br><span class="hljs-emphasis">    width: 100%; /*</span> 宽度占满容器 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    max-width: 1040px; /*</span> 最大宽度限制 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    margin: 0 auto; /*</span> 水平居中 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    text-align: center; /*</span> 文本居中 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  &#125;</span><br><span class="hljs-emphasis">  /*</span> 图片卡片样式 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  .card &#123;</span><br><span class="hljs-emphasis">    overflow: hidden; /*</span> 超出部分隐藏 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    transition: .3s ease-in-out; /*</span> 过渡效果，持续时间和缓动函数 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    border-radius: 8px; /*</span> 边框圆角 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    background-color: #efefef; /*</span> 背景颜色 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    padding: 1.4px; /*</span> 内边距 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  &#125;</span><br><span class="hljs-emphasis">  /*</span> 图片在卡片中的样式 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  .ImageInCard img &#123;</span><br><span class="hljs-emphasis">    padding: 0; /*</span> 图片内边距 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    border-radius: 8px; /*</span> 图片圆角 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    width:100%; /*</span> 图片宽度占满卡片 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">    height:100%; /*</span> 图片高度占满卡片 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  &#125;</span><br><span class="hljs-emphasis">  /*</span> 暗色模式下的样式 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  @media (prefers-color-scheme: dark) &#123;</span><br><span class="hljs-emphasis">    .card &#123;background-color: #333;&#125; /*</span> 暗色模式下卡片的背景颜色 <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">  &#125;</span><br><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"># HTML容器定义</span><br><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;imageTab&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> &lt;!-- 图片标签容器 --&gt;</span><br><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ImageGrid&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> &lt;!-- 图片网格容器 --&gt;</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>在 <code>_config.fluid.yml</code> 文件的 menu 里添加如下内容，这样就可以在页面右上角生成图标快速访问此页面了：</p><p><img src="https://cdn.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20240918210034185.png" alt="image-20240918210034185"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;摄影&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/photo/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-image&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-准备图片"><a href="#2-准备图片" class="headerlink" title="-2- 准备图片"></a>-2- 准备图片</h2><p>由于照片的展示是瀑布流的形式，所以需要先生成缩略图来加快页面加载，生成缩略图采用的是python脚本，将其放在了<code>tools</code>目录下</p><p>需要用到pillow模块，所以需要先安装PIL</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install pillow<br></code></pre></td></tr></table></figure><p>其主要功能就是从同级的<code>ori_picture</code>目录下读取文件，生成缩略图后添加<code>_mini</code>文件名后缀，放入<code>mini_picture</code>目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-comment"># 创建目录用于存储生成的图片</span><br>save_dirname = <span class="hljs-string">&quot;mini_picture&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(save_dirname):<br>    os.mkdir(save_dirname)<br><br>dirname = <span class="hljs-string">&quot;ori_picture&quot;</span><br>imgs = [os.path.join(dirname, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(dirname)]<br><br><span class="hljs-keyword">for</span> idx, img_path <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(imgs):<br>    <span class="hljs-keyword">if</span> img_path.endswith(<span class="hljs-string">&quot;jpg&quot;</span>) <span class="hljs-keyword">or</span> img_path.endswith(<span class="hljs-string">&quot;png&quot;</span>) <span class="hljs-keyword">or</span> img_path.endswith(<span class="hljs-string">&quot;jpeg&quot;</span>):<br>        original_filename, extension = os.path.splitext(os.path.basename(img_path))<br>        img = Image.<span class="hljs-built_in">open</span>(img_path)<br>        img.thumbnail((<span class="hljs-number">240</span>, <span class="hljs-number">480</span>))<br>        <br>        <span class="hljs-comment"># 构造新的文件名，加上 &quot;_mini&quot; 后缀</span><br>        new_filename = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;original_filename&#125;</span>_mini<span class="hljs-subst">&#123;extension&#125;</span>&quot;</span><br>        <br>        img.save(os.path.join(save_dirname, new_filename))<br><br></code></pre></td></tr></table></figure><h2 id="3-生成image-json"><a href="#3-生成image-json" class="headerlink" title="-3- 生成image.json"></a>-3- 生成image.json</h2><p>先安装image-size</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm i image-size<br></code></pre></td></tr></table></figure><blockquote><p>image-size 的功能是获取图片的宽高信息，不支持获取非图片格式的宽高，比如视频。</p></blockquote><p>然后使用 phototool.js 生成 image.json，脚本由来自<a href="https://weichao.io/09dacc5ba02c/#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF">为 Hexo + Fluid 博客添加承载相册的页面 - 『魏超』的 blog</a>，注释由GLM AI生成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>; <span class="hljs-comment">// 启用严格模式，确保代码运行在更严格的语法环境中</span><br><br><span class="hljs-keyword">const</span> sizeOf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;image-size&#x27;</span>); <span class="hljs-comment">// 引入image-size模块，用于获取图片尺寸</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>); <span class="hljs-comment">// 引入path模块，用于处理文件路径</span><br><span class="hljs-keyword">const</span> &#123; readdir, writeFileSync, stat &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-property">promises</span>; <span class="hljs-comment">// 引入fs模块的Promise版本，用于异步文件操作</span><br><br><span class="hljs-keyword">const</span> imagesSrcPath = <span class="hljs-string">&#x27;images/original-image/&#x27;</span>; <span class="hljs-comment">// 原始图片存放路径</span><br><span class="hljs-keyword">const</span> imagesThumbPath = <span class="hljs-string">&#x27;images/mini-image/&#x27;</span>; <span class="hljs-comment">// 缩略图存放路径</span><br><span class="hljs-keyword">const</span> sourcePath = <span class="hljs-string">&#x27;source/&#x27;</span>; <span class="hljs-comment">// 输出JSON文件的路径</span><br><br><span class="hljs-comment">// 定义异步函数，处理每个图片页面</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processPages</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> pageArr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readdir</span>(imagesSrcPath); <span class="hljs-comment">// 读取原始图片目录下的所有页面目录</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> page <span class="hljs-keyword">of</span> pageArr) &#123; <span class="hljs-comment">// 遍历每个页面目录</span><br>            <span class="hljs-keyword">const</span> pageSrcPath = path.<span class="hljs-title function_">join</span>(imagesSrcPath, page); <span class="hljs-comment">// 构建当前页面的原始图片路径</span><br>            <span class="hljs-keyword">const</span> pageThumbPath = path.<span class="hljs-title function_">join</span>(imagesThumbPath, page); <span class="hljs-comment">// 构建当前页面的缩略图路径</span><br>            <span class="hljs-keyword">const</span> output = path.<span class="hljs-title function_">join</span>(sourcePath, page, <span class="hljs-string">&#x27;image.json&#x27;</span>); <span class="hljs-comment">// 构建输出JSON文件的路径</span><br>            <br>            <span class="hljs-keyword">const</span> filesInPage = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readdir</span>(pageSrcPath); <span class="hljs-comment">// 读取当前页面目录下的所有相册目录</span><br><br>            <span class="hljs-keyword">let</span> imagesInPage = []; <span class="hljs-comment">// 初始化当前页面的图片信息数组</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> album <span class="hljs-keyword">of</span> filesInPage) &#123; <span class="hljs-comment">// 遍历每个相册目录</span><br>                <span class="hljs-keyword">const</span> albumSrcPath = path.<span class="hljs-title function_">join</span>(pageSrcPath, album); <span class="hljs-comment">// 构建当前相册的原始图片路径</span><br>                <span class="hljs-keyword">const</span> albumThumbPath = path.<span class="hljs-title function_">join</span>(pageThumbPath, album); <span class="hljs-comment">// 构建当前相册的缩略图路径</span><br>                <br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> albumStat = <span class="hljs-keyword">await</span> <span class="hljs-title function_">stat</span>(albumSrcPath); <span class="hljs-comment">// 获取当前相册的文件状态</span><br><br>                    <span class="hljs-keyword">if</span> (albumStat.<span class="hljs-title function_">isDirectory</span>()) &#123; <span class="hljs-comment">// 如果是目录，则处理该相册</span><br>                        <span class="hljs-keyword">let</span> imagesInAlbum = &#123; <span class="hljs-attr">name</span>: album &#125;; <span class="hljs-comment">// 初始化当前相册的图片信息对象</span><br>                        <span class="hljs-keyword">let</span> children = []; <span class="hljs-comment">// 初始化当前相册的图片子项数组</span><br><br>                        <span class="hljs-keyword">const</span> imageFile = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readdir</span>(albumSrcPath); <span class="hljs-comment">// 读取当前相册目录下的所有图片文件</span><br><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> imageFile) &#123; <span class="hljs-comment">// 遍历每个图片文件</span><br>                            <span class="hljs-keyword">if</span> (path.<span class="hljs-title function_">extname</span>(file) !== <span class="hljs-string">&quot;.mp4&quot;</span>) &#123; <span class="hljs-comment">// 如果文件不是视频，则处理图片</span><br>                                <span class="hljs-keyword">const</span> dimensions = <span class="hljs-title function_">sizeOf</span>(path.<span class="hljs-title function_">join</span>(albumSrcPath, file)); <span class="hljs-comment">// 获取图片尺寸</span><br>                                <span class="hljs-comment">// 生成并添加缩略图信息</span><br>                                <span class="hljs-keyword">const</span> thumbnailName = file.<span class="hljs-title function_">replace</span>(path.<span class="hljs-title function_">extname</span>(file), <span class="hljs-string">&#x27;_mini&#x27;</span> + path.<span class="hljs-title function_">extname</span>(file));<br>                                children.<span class="hljs-title function_">push</span>(dimensions.<span class="hljs-property">width</span> + <span class="hljs-string">&#x27;.&#x27;</span> + dimensions.<span class="hljs-property">height</span> + <span class="hljs-string">&#x27; &#x27;</span> + file + <span class="hljs-string">&#x27; &#x27;</span> + thumbnailName);<br>                            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果是视频文件，则处理对应的缩略图</span><br>                                <span class="hljs-keyword">const</span> dimensions = <span class="hljs-title function_">sizeOf</span>(path.<span class="hljs-title function_">join</span>(albumThumbPath, path.<span class="hljs-title function_">basename</span>(file, <span class="hljs-string">&quot;.mp4&quot;</span>) + <span class="hljs-string">&quot;.png&quot;</span>));<br>                                children.<span class="hljs-title function_">push</span>(dimensions.<span class="hljs-property">width</span> + <span class="hljs-string">&#x27;.&#x27;</span> + dimensions.<span class="hljs-property">height</span> + <span class="hljs-string">&#x27; &#x27;</span> + file + <span class="hljs-string">&#x27; &#x27;</span> + path.<span class="hljs-title function_">basename</span>(file, <span class="hljs-string">&quot;.mp4&quot;</span>) + <span class="hljs-string">&quot;.png&quot;</span>);<br>                            &#125;<br>                        &#125;<br><br>                        imagesInAlbum.<span class="hljs-property">children</span> = children; <span class="hljs-comment">// 将图片子项数组赋值给相册信息对象的children属性</span><br>                        imagesInPage.<span class="hljs-title function_">push</span>(imagesInAlbum); <span class="hljs-comment">// 将相册信息对象添加到当前页面的图片信息数组</span><br>                        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <span class="hljs-comment">// 引入fs模块，用于写入文件</span><br>fs.<span class="hljs-title function_">writeFileSync</span>(output, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(imagesInPage, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;\t&quot;</span>)); <span class="hljs-comment">// 将当前页面的图片信息数组写入JSON文件</span><br><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error); <span class="hljs-comment">// 捕获并打印错误信息</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error); <span class="hljs-comment">// 捕获并打印错误信息</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">processPages</span>(); <span class="hljs-comment">// 调用函数，开始处理图片页面</span><br><br></code></pre></td></tr></table></figure><p>执行后会在 <code>source</code> 内对应页面的文件夹内生成 <code>image.json</code></p><blockquote><p>放在 <code>scripts</code> 内的 js 文件在执行 Hexo 部分命令 比如 <code>hexo s -d</code> 时会被自动执行。</p></blockquote><h2 id="4-加载图片到页面"><a href="#4-加载图片到页面" class="headerlink" title="-4- 加载图片到页面"></a>-4- 加载图片到页面</h2><p>现在图片和描述图片信息的json文件都准备好了，就差把图片加载到页面上了</p><p>这里需要两个js脚本，一个是<code>injector.js</code>，用到了[<code>Hexo 注入器</code>](<a href="https://hexo.fluid-dev.com/docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">进阶用法 | Hexo Fluid 用户手册 (fluid-dev.com)</a>)，用于将 HTML 片段注入生成页面的 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 节点中。</p><p>另一个是用于生成瀑布流形式的页面布局的<code>gallery.js</code></p><p><strong>gallery.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgDataPath = <span class="hljs-string">&quot;image.json&quot;</span>; <span class="hljs-comment">// 图片数据文件路径，包含图片所在相册、高宽、名称等信息</span><br><span class="hljs-keyword">var</span> imgPath = <span class="hljs-string">&quot;https://gcore.jsdelivr.net/gh/GoooForward/blog@source/images/original-image/photo/&quot;</span>; <span class="hljs-comment">// 原图的网络访问路径</span><br><span class="hljs-keyword">var</span> imgThumbPath = <span class="hljs-string">&quot;https://gcore.jsdelivr.net/gh/GoooForward/blog@source/images/mini-image/photo/&quot;</span>; <span class="hljs-comment">// 缩略图的网络访问路径</span><br><br><span class="hljs-comment">// 获取窗口宽度，用于判断是否为手机端</span><br><span class="hljs-keyword">var</span> windowWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br><span class="hljs-comment">// 根据窗口宽度设置图片显示宽度</span><br><span class="hljs-keyword">if</span> (windowWidth &lt; <span class="hljs-number">768</span>) &#123; <span class="hljs-comment">// 如果窗口宽度小于768px，认为是手机端</span><br>  <span class="hljs-keyword">var</span> imageWidth = <span class="hljs-number">145</span>; <span class="hljs-comment">// 图片显示宽度设置为145px</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">var</span> imageWidth = <span class="hljs-number">250</span>; <span class="hljs-comment">// 图片显示宽度设置为250px</span><br>&#125;<br><br><span class="hljs-keyword">const</span> photo = &#123;<br>  <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 当前页面索引</span><br>  <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 初始化函数</span><br>    <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 使用jQuery的getJSON方法异步加载图片数据文件</span><br>    $.<span class="hljs-title function_">getJSON</span>(imgDataPath, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>      that.<span class="hljs-title function_">render</span>(that.<span class="hljs-property">page</span>, data); <span class="hljs-comment">// 渲染图片</span><br>      <span class="hljs-comment">//that.scroll(data); // 假设这里有滚动相关处理，已被注释</span><br>      that.<span class="hljs-title function_">eventListen</span>(data); <span class="hljs-comment">// 绑定事件监听</span><br>    &#125;);<br>  &#125;,<br>  <span class="hljs-attr">constructHtml</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123; <span class="hljs-comment">// 构建HTML字符串的函数</span><br>    <span class="hljs-comment">// 解构赋值获取参数</span><br>    <span class="hljs-keyword">const</span> &#123;<br>      imageWidth,<br>      imageX,<br>      imageY,<br>      name,<br>      imgPath,<br>      imgThumbPath,<br>      imgName,<br>      imgNameWithPattern,<br>      imgThumbNameWithPattern,<br>    &#125; = options;<br>    <span class="hljs-comment">// 构建图片卡片HTML元素</span><br>    <span class="hljs-keyword">const</span> htmlEle = <span class="hljs-string">`&lt;div class=&quot;card lozad&quot; style=&quot;width:<span class="hljs-subst">$&#123;imageWidth&#125;</span>px&quot;&gt;</span><br><span class="hljs-string">                  &lt;div class=&quot;ImageInCard&quot; style=&quot;height:<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">                    (imageWidth * imageY) / imageX</span></span><br><span class="hljs-subst"><span class="hljs-string">                  &#125;</span>px&quot;&gt;</span><br><span class="hljs-string">                    &lt;a data-fancybox=&quot;gallery&quot; href=&quot;<span class="hljs-subst">$&#123;imgPath&#125;</span><span class="hljs-subst">$&#123;name&#125;</span>/<span class="hljs-subst">$&#123;imgNameWithPattern&#125;</span>&quot;</span><br><span class="hljs-string">                          data-caption=&quot;<span class="hljs-subst">$&#123;imgName&#125;</span>&quot; title=&quot;<span class="hljs-subst">$&#123;imgName&#125;</span>&quot;&gt;</span><br><span class="hljs-string">                            &lt;img  class=&quot;lazyload&quot; data-src=&quot;<span class="hljs-subst">$&#123;imgThumbPath&#125;</span><span class="hljs-subst">$&#123;name&#125;</span>/<span class="hljs-subst">$&#123;imgThumbNameWithPattern&#125;</span>&quot;</span><br><span class="hljs-string">                            src=&quot;data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&quot;</span><br><span class="hljs-string">                            onload=&quot;lzld(this)&quot;</span><br><span class="hljs-string">                            lazyload=&quot;auto&quot;&gt;</span><br><span class="hljs-string">                        &lt;/a&gt;</span><br><span class="hljs-string">                  &lt;/div&gt;</span><br><span class="hljs-string">                &lt;/div&gt;`</span>;<br>    <span class="hljs-keyword">return</span> htmlEle; <span class="hljs-comment">// 返回构建好的HTML字符串</span><br>  &#125;,<br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">page, data = []</span>) &#123; <span class="hljs-comment">// 渲染图片的函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data; <span class="hljs-comment">// 将数据赋值给实例属性</span><br>    <span class="hljs-keyword">if</span> (!data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果没有数据，则直接返回</span><br>    <span class="hljs-keyword">var</span> html,<br>      imgNameWithPattern,<br>      imgThumbNameWithPattern,<br>      imgName,<br>      imageSize,<br>      imageX,<br>      imageY,<br>      li = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> liHtml = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 初始化相册导航HTML</span><br>    <span class="hljs-keyword">let</span> contentHtml = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 初始化相册内容HTML</span><br><br>    <span class="hljs-comment">// 遍历数据，构建相册导航和内容</span><br>    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> activeClass = index === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;active&quot;</span> : <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 判断是否为激活状态</span><br>      liHtml += <span class="hljs-string">`&lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;</span><br><span class="hljs-string">          &lt;a class=&quot;nav-link <span class="hljs-subst">$&#123;activeClass&#125;</span> photo-tab&quot; id=&quot;home-tab&quot; photo-uuid=&quot;<span class="hljs-subst">$&#123;item.name&#125;</span>&quot; data-toggle=&quot;tab&quot; href=&quot;#<span class="hljs-subst">$&#123;item.name&#125;</span>&quot;  role=&quot;tab&quot; aria-controls=&quot;<span class="hljs-subst">$&#123;item.name&#125;</span>&quot; aria-selected=&quot;true&quot;&gt;<span class="hljs-subst">$&#123;item.name&#125;</span>&lt;/a&gt;</span><br><span class="hljs-string">        &lt;/li&gt;`</span>;<br>    &#125;);<br>    <span class="hljs-comment">// 获取第一个相册的数据</span><br>    <span class="hljs-keyword">const</span> [initData = &#123;&#125;] = data;<br>    <span class="hljs-keyword">const</span> &#123; children = [], name &#125; = initData;<br>    <span class="hljs-comment">// 遍历相册中的图片，构建HTML</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>      imgNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>      imgThumbNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">2</span>];<br>      imgName = imgNameWithPattern.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>      imageSize = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>];<br>      imageX = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>      imageY = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">let</span> imgOptions = &#123;<br>        imageWidth,<br>        imageX,<br>        imageY,<br>        name,<br>        imgName,<br>        imgPath,<br>        imgThumbPath,<br>        imgNameWithPattern,<br>        imgThumbNameWithPattern,<br>      &#125;;<br>      li += <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">constructHtml</span>(imgOptions); <span class="hljs-comment">// 构建图片HTML</span><br>    &#125;);<br>    <span class="hljs-comment">// 构建相册内容HTML</span><br>    contentHtml += <span class="hljs-string">` &lt;div class=&quot;tab-pane fade show active&quot; id=&quot;<span class="hljs-subst">$&#123;initData.name&#125;</span>&quot; role=&quot;tabpanel&quot; aria-labelledby=&quot;home-tab&quot;&gt;<span class="hljs-subst">$&#123;li&#125;</span>&lt;/div&gt;`</span>; <span class="hljs-comment">// 添加第一个相册的内容HTML，并设置为激活状态</span><br><br>    <span class="hljs-keyword">const</span> ulHtml = <span class="hljs-string">`&lt;ul class=&quot;nav nav-tabs&quot; id=&quot;myTab&quot; role=&quot;tablist&quot;&gt;<span class="hljs-subst">$&#123;liHtml&#125;</span>&lt;/ul&gt;`</span>; <span class="hljs-comment">// 构建相册导航的HTML</span><br>    <span class="hljs-keyword">const</span> tabContent = <span class="hljs-string">`&lt;div class=&quot;tab-content&quot; id=&quot;myTabContent&quot;&gt;<span class="hljs-subst">$&#123;contentHtml&#125;</span>&lt;/div&gt;`</span>; <span class="hljs-comment">// 构建包含所有相册内容的HTML</span><br><br>    <span class="hljs-comment">// 将相册导航和内容添加到页面对应的元素中</span><br>    $(<span class="hljs-string">&quot;#imageTab&quot;</span>).<span class="hljs-title function_">append</span>(ulHtml);<br>    $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">append</span>(tabContent);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minigrid</span>(); <span class="hljs-comment">// 调用minigrid函数，初始化图片网格布局</span><br>  &#125;,<br>  <span class="hljs-attr">eventListen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123; <span class="hljs-comment">// 事件监听函数</span><br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 监听标签页切换事件</span><br>    $(<span class="hljs-string">&#x27;a[data-toggle=&quot;tab&quot;]&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;shown.bs.tab&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">empty</span>(); <span class="hljs-comment">// 清空当前图片网格内容</span><br>      <span class="hljs-keyword">const</span> selectId = $(e.<span class="hljs-property">target</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;photo-uuid&quot;</span>); <span class="hljs-comment">// 获取被选中标签的相册ID</span><br>      <span class="hljs-keyword">const</span> selectedData = data.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> data.<span class="hljs-property">name</span> === selectId) || &#123;&#125;; <span class="hljs-comment">// 从数据中找到被选中的相册数据</span><br>      <span class="hljs-keyword">const</span> &#123; children, name &#125; = selectedData; <span class="hljs-comment">// 解构赋值获取相册的图片数据</span><br>      <span class="hljs-keyword">let</span> li = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 初始化相册内容HTML</span><br>      <span class="hljs-comment">// 遍历相册中的图片，构建HTML</span><br>      children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        imgNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>        imgThumbNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">2</span>];<br>        imgName = imgNameWithPattern.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>        imageSize = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>];<br>        imageX = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>        imageY = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> imgOptions = &#123;<br>          imageWidth,<br>          imageX,<br>          imageY,<br>          name,<br>          imgName,<br>          imgPath,<br>          imgThumbPath,<br>          imgNameWithPattern,<br>          imgThumbNameWithPattern,<br>        &#125;;<br>        li += self.<span class="hljs-title function_">constructHtml</span>(imgOptions); <span class="hljs-comment">// 构建图片HTML</span><br>      &#125;);<br>      <span class="hljs-comment">// 将构建好的相册内容HTML添加到页面对应的元素中</span><br>      $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">append</span>(li);<br>      self.<span class="hljs-title function_">minigrid</span>(); <span class="hljs-comment">// 重新初始化图片网格布局</span><br>    &#125;);<br>  &#125;,<br>  <span class="hljs-attr">minigrid</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 初始化图片网格布局的函数</span><br>    <span class="hljs-keyword">var</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Minigrid</span>(&#123; <span class="hljs-comment">// 创建Minigrid实例</span><br>      <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;.ImageGrid&quot;</span>, <span class="hljs-comment">// 网格容器的选择器</span><br>      <span class="hljs-attr">item</span>: <span class="hljs-string">&quot;.card&quot;</span>, <span class="hljs-comment">// 网格项的选择器</span><br>      <span class="hljs-attr">gutter</span>: <span class="hljs-number">12</span>, <span class="hljs-comment">// 网格项之间的间隔</span><br>    &#125;);<br>    grid.<span class="hljs-title function_">mount</span>(); <span class="hljs-comment">// 初始化网格布局</span><br>    <span class="hljs-comment">// 监听窗口大小变化事件，重新初始化网格布局</span><br>    $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">resize</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      grid.<span class="hljs-title function_">mount</span>();<br>    &#125;);<br>  &#125;,<br>&#125;;<br>photo.<span class="hljs-title function_">init</span>(); <span class="hljs-comment">// 调用photo对象的init方法，开始初始化过程</span><br><br></code></pre></td></tr></table></figure><p><strong>injector.js</strong></p><p>在 <code>layout: photo</code> 时会导入下面的 js 与 css，这里的 layout 就是 <code>index.md</code> 里的 layout，其中包括 <code>gallery.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/&quot;</span> &#125; = hexo.<span class="hljs-property">config</span>;<br><span class="hljs-comment">// layout 为 photo的时候导入这些js与css</span><br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<br>  <span class="hljs-string">&quot;body_end&quot;</span>,<br>  <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css&quot;&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;//cdn.jsdelivr.net/npm/minigrid@3.1.1/dist/minigrid.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/lazyloadjs/3.2.2/lazyload.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;script defer src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/gallery.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  `</span>,<br>  <span class="hljs-string">&quot;photo&quot;</span><br>);<br></code></pre></td></tr></table></figure><blockquote><p><code>injector.js</code>放在scripts目录下，自动执行，将<code>gallery.js</code>注入到photo下的index页面中</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="/blog/2023/11/06/study/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2023/11/06/study/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>从前的我并不知道什么是make，这主要有两个原因，一是从前学习编程都是使用的都是windows平台，二是早期学习编程大都是单个文件实现一个简单的功能，不涉及到多文件编译，也用不到make。在windows平台，大多数项目有完备的IDE可以使用，像Visual Studio，MDK之类的，对于多文件的项目，它们都会有一个项目文件，通过项目文件打开该项目就能很容易的实现多文件编译。然而，随着学习的深入，越来越多的时候都在使用Linux开发，对于那些没有完备IDE支持的项目，学习如何自动化编译多文件项目就变得越来越重要。</p><p>其实，在这次下定决心学习Makefile之前，我其实也学习了Makefile几次，但是都浅尝辄止，半途而废了，仅仅只是学习了一些最最基础的语法，然而实际工作中，发现我学习的那些最基础的东西连项目给出的Makefile都读不懂，这次我决定一口气认认真真地学完Makefile，至少做到能看懂项目的Makefile，对于自己的一些小项目的Makefile要能够写出来。</p><p>学习Makefile，我选择的教材是我之前就学习过的陈皓大佬的<a href="https://seisman.github.io/how-to-write-makefile/overview.html">《跟我一起写Makefile》</a>。</p><p>其他资料：<a href="https://www.gnu.org/software/make/manual/make.html">GNU make手册</a></p><h1 id="0x01-什么是Makefile"><a href="#0x01-什么是Makefile" class="headerlink" title="0x01 什么是Makefile"></a>0x01 什么是Makefile</h1><h2 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="-1- 编译过程"></a>-1- 编译过程</h2><p>要了解Makefile首先要复习一下C文件的编译过程。这里要搬出一张经典的图片了。这里的预处理器，编译器，汇编器，连接器分别对应了不同的工具，这些工具共同组成了编译器。<br><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202311061550545.png"></p><p>对于多文件项目，首先会将不同的源文件编译为目标文件，在Windows下也就是 <code>.obj</code> 文件，UNIX下是 <code>.o</code> 文件，即Object File。然后再将大量的目标文件连接在一起成为可执行文件，这个动作被叫做连接。</p><blockquote><p>链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（ <code>.o</code> 文件或 <code>.obj</code> 文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File），也就是 <code>.lib</code> 文件，在UNIX下，是Archive File，也就是 <code>.a</code> 文件。</p><p><a href="https://blog.csdn.net/ahelloyou/article/details/112620353">程序运行库文件链接原理</a></p></blockquote><h2 id="2-make简介"><a href="#2-make简介" class="headerlink" title="-2- make简介"></a>-2- make简介</h2><p>make是Linux上最常用的项目管理工具，make命令可以帮助我们自动化完成上面提到的文件编译过程，并且帮助我们管理好源文件之间的依赖关系，当有源文件发生变化时，所有依赖于此源文件的源代码都会被重新编译。</p><p>make命令并不能凭空管理项目，它需要一个Makefile文件来描述项目中源文件的依赖关系，以及编译方法。所以学习使用make，就是学习如何编写Makefile。</p><p>makefile的文件名通常有三种格式：Makefile、makefile、GNUmakefile，make会在当前目录下自动寻找找三个文件名，如果没有找到的话，make就无法继续编译程序，产生一个错误并退出。</p><h1 id="0x02-初识Makefile"><a href="#0x02-初识Makefile" class="headerlink" title="0x02 初识Makefile"></a>0x02 初识Makefile</h1><h2 id="1-makefile基本规则"><a href="#1-makefile基本规则" class="headerlink" title="-1- makefile基本规则"></a>-1- makefile基本规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure><ul><li><p>target</p><p>可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p></li><li><p>prerequisites</p><p>生成该target所依赖的文件和&#x2F;或target。</p></li><li><p>command</p><p>该target要执行的命令（任意的shell命令）。</p></li></ul><p>这种格式描述了文件之间的依赖关系，也就是target依赖于prerequisites，且target这个文件的生成规则描述在recipe中。通俗来说就是：<strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong></p><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o \<br>        insert.o search.o files.o utils.o<br>    cc -o edit main.o kbd.o command.o display.o \<br>        insert.o search.o files.o utils.o<br><br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h buffer.h<br>    cc -c display.c<br>insert.o : insert.c defs.h buffer.h<br>    cc -c insert.c<br>search.o : search.c defs.h buffer.h<br>    cc -c search.c<br>files.o : files.c defs.h buffer.h command.h<br>    cc -c files.c<br>utils.o : utils.c defs.h<br>    cc -c utils.c<br>clean :<br>    rm edit main.o kbd.o command.o display.o \<br>        insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure><blockquote><p><strong>关于CC与GCC</strong></p><p>CC就是是C compiler，即C编译器，而GCC是GNU CC，也就是GNU C编译器，在linux中，cc实际上就是指向gcc，这是因为cc是Unix的软件，是要收费的，因此GNU组织就编写了免费开源的gcc来取代cc。</p><p><a href="https://www.cnblogs.com/zhouyinhui/archive/2010/02/01/1661078.html">Linux下的cc与gcc</a></p></blockquote><p>在这个makefile中，目标文件（target）包含：可执行文件edit和中间目标文件（ <code>*.o</code> ），依赖文件（prerequisites）就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code> 文件又是可执行文件 <code>edit</code> 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>以上的两个部分其实已经定义好了文件之间的依赖关系，但是在目标文件与依赖文件之间还缺少一个转化的桥梁，也就是我们还不知道如何将依赖文件转变为目标文件，所以其后的recipe就定义了如何将依赖文件变为目标文件的系统命令。但是值得注意的是，recipe中的命令完全是自定义的，make并不会去解读你的命令，它只会执行你所定义的命令。格式上，recipe一定要以指标符tab开头。</p><p>在给出的例子中，作为目标<code>target</code>的<code>clean</code>并不是一个文件，而是一个标签<code>label</code>，就和C语言中goto跳转的标签类似，它没有依赖文件，因此在执行make时不会自动执行，只有在显式的指出目标为clean时（<code>make clean</code>）才会执行其定义的recipe命令。借助这个特性，我们可以在makefile中定义很多非编译的但是能提高工作效率的命令，例如帮助我们清理构建文件 、程序打包、备份等等。</p><h2 id="2-make是如何工作的"><a href="#2-make是如何工作的" class="headerlink" title="-2- make是如何工作的"></a>-2- make是如何工作的</h2><p>在默认情况下，当我们在命令行中输入<code>make</code>时，make将会照如下的顺序执行</p><ol><li>make首先会在当前目录寻找<code>Makefile</code>或者<code>makefile</code></li><li>如果找到，就会自动读取到第一个目标（这个目标可以是目标文件，也可以是label，make不做判断），这个目标就是make的最终目标，在前面的例子中，就是edit这个文件</li><li>如果edit这个文件不存在，或者是edit后面所依赖的文件（包括依赖文件的依赖文件）的修改时间要比edit更新，那么make就会自动执行command中所定义的命令来生成edit这个文件</li><li>如果edit的依赖文件中也有不存在的，或者不是最新的，那么make就会去寻找以该依赖文件为目标的规则，然后按照相同的过程去执行command命令生成这个依赖文件（就是一种递归）</li><li>最后edit的所有依赖文件都集齐了，就会执行edit对应的command命令，最后生成edit这个文件</li></ol><p>在make的工作流程中，首先在读取最终目标时，make只会把一个target作为它的最终目标，只要此target规则中的依赖文件都集齐了，就会自动执行其后的shell命令，如果将clean的规则放在文件最开头，那么执行make也只会自动执行清除的命令，而后面的编译部分就全部不执行了。</p><p>其次，在检测依赖文件的修改时间时，要注意依赖文件的依赖也是当前目标文件的依赖，也是会检测的。举个例子，当已经执行了一次编译，此时所有的目标文件都已经生成了，然后修改其中的一个源文件<code>files.c</code>，然后执行make，按照执行流程，会选择edit作为最终目标，然后检测edit是否比它的依赖更新，<code>files.c</code>不是edit的依赖，但是却是<code>files.o</code>的依赖，而<code>files.o</code>是edit的依赖，因此<code>files.c</code>也可以视为edit的依赖，执行时会先重新生成<code>files.o</code>然后生成最终目标<code>edit</code>。</p><h2 id="3-makefile-中使用变量"><a href="#3-makefile-中使用变量" class="headerlink" title="-3- makefile 中使用变量"></a>-3- makefile 中使用变量</h2><p>在编写makefile时，特别是大型的makefile时，可能会遇到同一段字符串被反复使用，例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br>    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure><p>这里的依赖<code>.o</code>文件和后面command命令中所指明的<code>.o</code>文件都是一样的，当我们想要添加新的<code>.o</code>文件时，就需要在不同的地方手动添加，makefile足够大时，手动添加很难保证不出错，这极大地增加了makefile的维护成本。所以我们可以使用变量来代替原本的一连串<code>.o</code>文件，makefile中变量的本质类似于C语言中的宏定义，只做文本替换。我们用<code>object</code>来代替原本的一连串<code>.o</code>文件，原本的makefile就改进为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o \<br>    insert.o search.o files.o utils.o<br><br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h buffer.h<br>    cc -c display.c<br>insert.o : insert.c defs.h buffer.h<br>    cc -c insert.c<br>search.o : search.c defs.h buffer.h<br>    cc -c search.c<br>files.o : files.c defs.h buffer.h command.h<br>    cc -c files.c<br>utils.o : utils.c defs.h<br>    cc -c utils.c<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><h2 id="4-makefile-的自动推导机制"><a href="#4-makefile-的自动推导机制" class="headerlink" title="-4- makefile 的自动推导机制"></a>-4- makefile 的自动推导机制</h2><p>make可以自动推导出目标文件以及其依赖文件后面的命令，当make找到一个<code>xxx.o</code>文件，它就会自动把<code>xxx.c</code>加入到其依赖中，并且自动脑补出<code>cc -c xxx.c</code>的命令，因此，借助这个机制，makefile又可以被简化为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o \<br>    insert.o search.o files.o utils.o<br><br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br><br>main.o : defs.h<br>kbd.o : defs.h command.h<br>command.o : defs.h command.h<br>display.o : defs.h buffer.h<br>insert.o : defs.h buffer.h<br>search.o : defs.h buffer.h<br>files.o : defs.h buffer.h command.h<br>utils.o : defs.h<br><br>.PHONY : clean<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>这种书写方法属于make的<strong>隐式规则</strong>。<code>.PHONY : clean</code>表示clean是一个伪目标。</p><h2 id="5-以源文件为中心的makefile风格"><a href="#5-以源文件为中心的makefile风格" class="headerlink" title="-5- 以源文件为中心的makefile风格"></a>-5- 以源文件为中心的makefile风格</h2><p>前面借助make的自动推导机制已经实现了省略了各<code>.c</code>文件，只留下了各自依赖的<code>.h</code>头文件，经过观察，可以发现这些不同的目标文件都依赖于几个相同的<code>.h</code>头文件。前面给出的makefile都是以不同的目标文件为中心编写的，其本质是列举出每个目标文件受哪些依赖文件的影响，那么是否可以反过来，以源文件（依赖文件）为中心，列举出不同源文件能影响哪些目标文件，答案自然是肯定的。新风格的makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o \<br>    insert.o search.o files.o utils.o<br><br>edit : <span class="hljs-variable">$(objects)</span><br>    cc -o edit <span class="hljs-variable">$(objects)</span><br><br><span class="hljs-variable">$(objects)</span> : defs.h<br>kbd.o command.o files.o : command.h<br>display.o insert.o search.o files.o : buffer.h<br><br>.PHONY : clean<br>clean :<br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p><code>defs.h</code>会影响全部<code>.o</code>文件，<code>command.h</code>会影响<code>kbd.o</code> <code>command.o</code> <code>files.o</code>，<code>buffer.h</code>会影响<code>display.o</code> <code>insert.o</code> <code>search.o</code> <code>files.o </code> 。同时make的自动推导机制依然生效，每个<code>.o</code>文件依旧依赖于对应的<code>.c</code>文件。使用这种书写风格可以进一步简化makefile，同时也能表明文件之间的依赖关系。只不过采用这种风格会显得文件的依赖关系没那么清晰，需要阅读者在看的同时分析。</p><h2 id="6-清空目录的规则"><a href="#6-清空目录的规则" class="headerlink" title="-6- 清空目录的规则"></a>-6- 清空目录的规则</h2><p>每个Makefile中都应该写一个清空目标文件（ <code>.o</code> ）和可执行文件的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”，通常的写法是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>而更为标准的写法应该是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br>clean :<br>    -rm edit <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure><p>这里的<code>.PHONY</code>表明<code>clean</code>是一个伪目标。而在<code>rm</code>前面添加一个减号<code>-</code>表示当出现问题时，忽略错误，继续执行后面的内容。</p><p><code>clean</code> 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p><h2 id="7-makefile里有什么"><a href="#7-makefile里有什么" class="headerlink" title="-7- makefile里有什么"></a>-7- makefile里有什么</h2><p>Makefile里主要包含了五个东西：显式规则、隐式规则、变量定义、指令和注释。</p><ol><li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐式规则。由于我们的make有自动推导的功能，所以隐式规则可以让我们比较简略地书写Makefile，这是由make所支持的。</li><li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li><li>指令。其包括了三个部分：<ol><li>一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；</li><li>另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；</li><li>还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li></ol></li><li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 <code>#</code> 字符，这个就像C&#x2F;C++中的 <code>//</code> 一样。如果你要在你的Makefile中使用 <code>#</code> 字符，可以用反斜杠进行转义，如： <code>\#</code> 。</li></ol><h2 id="8-Makefile文件名"><a href="#8-Makefile文件名" class="headerlink" title="-8- Makefile文件名"></a>-8- Makefile文件名</h2><p>默认的情况下，make命令会在当前目录下按顺序寻找文件名为 <code>GNUmakefile</code> 、 <code>makefile</code> 和 <code>Makefile</code> 的文件。在这三个文件名中，最好使用 <code>Makefile</code> 这个文件名，因为这个文件名在排序上靠近其它比较重要的文件，比如 <code>README</code>。最好不要用 <code>GNUmakefile</code>，因为这个文件名只能由GNU <code>make</code> ，其它版本的 <code>make</code> 无法识别，但是基本上来说，大多数的 <code>make</code> 都支持 <code>makefile</code> 和 <code>Makefile</code> 这两种默认文件名。</p><p>当然，也可以使用别的文件名来书写Makefile，比如：“Make.Solaris”，“Make.Linux”等，如果要指定特定的Makefile，你可以使用make的 <code>-f</code> 或 <code>--file</code> 参数，如： <code>make -f Make.Solaris</code> 或 <code>make --file Make.Linux</code> 。如果你使用多条 <code>-f</code> 或 <code>--file</code> 参数，可以指定多个makefile。</p><h2 id="9-包含其他的Makefile"><a href="#9-包含其他的Makefile" class="headerlink" title="-9- 包含其他的Makefile"></a>-9- 包含其他的Makefile</h2><p>在Makefile使用 <code>include</code> 指令可以把别的Makefile包含进来，这很像C语言的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;filenames&gt;</span>...<br></code></pre></td></tr></table></figure><p><code>&lt;filenames&gt;</code> 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。</p><p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。 <code>include</code> 和 <code>&lt;filenames&gt;</code> 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： <code>a.mk</code> 、 <code>b.mk</code> 、 <code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code> ，其包含了 <code>bish</code> 和 <code>bash</code> ，那么，下面的语句：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-keyword">include</span> foo.make *.mk <span class="hljs-variable">$(</span>bar)<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> foo.make a.mk b.mk c.mk bish bash<br></code></pre></td></tr></table></figure><p>make命令开始时，会找寻 <code>include</code> 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C&#x2F;C++的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ol><li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>接下来按顺序寻找目录 <code>&lt;prefix&gt;/include</code> （一般是 <code>/usr/local/bin</code> ）、 <code>/usr/gnu/include</code> 、 <code>/usr/local/include</code> 、 <code>/usr/include</code> 。</li></ol><p>环境变量 <code>.INCLUDE_DIRS</code> 包含当前 make 会寻找的目录列表。你应当避免使用命令行参数 <code>-I</code> 来寻找以上这些默认目录，否则会使得 <code>make</code> “忘掉”所有已经设定的包含目录，包括默认目录。也就是说，使用了<code>-I</code>参数指定了include目录之后，make就只会在指定的目录下寻找，并且不再去默认的目录中寻找</p><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-keyword">-include</span> &lt;filenames&gt;...<br></code></pre></td></tr></table></figure><p>其表示，无论include过程中出现什么错误，都不要报错继续执行。如果要和其它版本 <code>make</code> 兼容，可以使用 <code>sinclude</code> 代替 <code>-include</code> 。</p><h2 id="10-环境变量MAKEFILES"><a href="#10-环境变量MAKEFILES" class="headerlink" title="-10- 环境变量MAKEFILES"></a>-10- 环境变量MAKEFILES</h2><p>如果当前的环境中定义了<code>MAKEFILES</code>，那么make会把这个变量中的值作为一个类似于<code>include</code>的操作。这个变量的值是其他的makefile，用空格隔开。它与用<code>include</code>引入的其他makefile不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><p>使用这个环境变量会对所有的Makefile起作用，这显然是我们不希望看到的，因此不推荐使用这个环境变量</p><h2 id="11-make的工作方式"><a href="#11-make的工作方式" class="headerlink" title="-11- make的工作方式"></a>-11- make的工作方式</h2><p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）</p><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐式规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p><h1 id="0x03-书写规则"><a href="#0x03-书写规则" class="headerlink" title="0x03 书写规则"></a>0x03 书写规则</h1><p>规则包含两个部分，一个是<strong>依赖关系</strong>，一个是<strong>生成目标的方法</strong>。</p><p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p><h2 id="1-规则的语法"><a href="#1-规则的语法" class="headerlink" title="-1- 规则的语法"></a>-1- 规则的语法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : prerequisites<br>    command<br>    ...<br></code></pre></td></tr></table></figure><p>或是这样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : prerequisites ; command<br>    command<br>    ...<br></code></pre></td></tr></table></figure><p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p><p>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 <code>Tab</code> 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。</p><p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。</p><p>如果命令太长，你可以使用反斜杠（ <code>\</code> ）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。</p><p>一般来说，make会以UNIX的标准Shell，也就是 <code>/bin/sh</code> 来执行命令。</p><h2 id="2-在规则中使用通配符"><a href="#2-在规则中使用通配符" class="headerlink" title="-2- 在规则中使用通配符"></a>-2- 在规则中使用通配符</h2><p>make支持三个通配符<code>*</code>,<code>?</code>和<code>~</code>。</p><ul><li><code>*</code>号代表任意个字符，这与正则表达式中的<code>*</code>号不同</li><li><code>?</code>号代表任意单个字符，但是此字符必须存在。这与正则表达式中的<code>?</code>号也不同</li><li><code>~</code>号代表<code>home</code>目录，在Unix环境下表示的就是当前用户的家目录路径， <code>~hchen/test</code> 则表示用户hchen的宿主目录下的test 目录。在Windows的下视<code>$HOME</code>的环境变量定义而定。</li></ul><p>这些通配符在变量中依然也是可以使用的，因为makefile的变量和宏定义一样，只做字符替换。</p><p>当然和正则表达式中的元字符一样，如果想要表示这些字符本身的意思，需要使用转义字符<code>\</code>来转义。</p><h2 id="3-文件搜索"><a href="#3-文件搜索" class="headerlink" title="-3- 文件搜索"></a>-3- 文件搜索</h2><p>在大型工程中，通常有许许多多的源文件，为了管理这些源文件，通常会将其分类存放在不同的路径中，但是在描述文件依赖关系时，就需要带上这些目录路径，这会导致Makefile臃肿，且难以阅读。一个更好的解决方法是给出一个路径，让make自己去路径下寻找，而非总是指明文件的路径。</p><p>Makefile中的<code>VPATH</code>特殊变量就是用于完成这个功能的，在未定义此变量的情况下，Makefile默认只会在当前目录下寻找依赖文件和目标文件。而定义了<code>VPATH</code>变量之后，make就会在当前目录没有找到的情况下，继续去<code>VPATH</code>所定义的路径下继续寻找。这里给出一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = src:../headers<br></code></pre></td></tr></table></figure><p>上面的定义指定了两个目录，“src”和“..&#x2F;headers”，make会按照这个顺序进行搜索。目录由“冒号:”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><p>另一个用于定义文件搜索路径的方法是使用关键字vpath（全小写），与前面提到的<code>VPATH</code>不同的是，<code>vpath</code>不是一个变量，而是一个make定义的关键字，它的使用方法更加灵活，它可以指定不同类型的文件在不同的路径下搜索。它主要有以下三种用法：</p><ul><li><pre><code class="makefile">vpath &lt;pattern&gt; &lt;directories&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  为符合\&lt;pattern\&gt;模式的文件指定搜索目录<br><br>* ```makefile<br>  vpath &lt;pattern&gt;<br></code></pre></td></tr></table></figure>清除符合\&lt;pattern\&gt;模式的文件的搜索目录</code></pre></li><li><pre><code class="makefile">vpath<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  清除所有设置好的文件的搜索目录<br><br><br><br>vpath使用方法中的\&lt;pattern\&gt;需要包含 `%` 字符。 `%` 的意思是匹配零或若干字符，（需引用 `%` ，使用 `\` ）例如， `%.h` 表示所有以 `.h` 结尾的文件。\&lt;pattern\&gt;指定了要搜索的文件集，而\&lt;directories\&gt;则指定了\&lt;pattern\&gt;的文件集的搜索的目录。例如：<br><br></code></pre></td></tr></table></figure>vpath %.h ../headers<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-string">该语句表示，要求make在“../headers”目录下搜索所有以</span> <span class="hljs-string">`.h`</span> <span class="hljs-string">结尾的文件。（如果某文件在当前目录没有找到的话）</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的\&lt;pattern\&gt;</span> <span class="hljs-string">，或是被重复了的\&lt;pattern\&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：</span><br><br><span class="hljs-string">```makefile</span><br><span class="hljs-string">vpath</span> <span class="hljs-string">%.c</span> <span class="hljs-string">foo</span><br><span class="hljs-string">vpath</span> <span class="hljs-string">%</span>   <span class="hljs-string">blish</span><br><span class="hljs-string">vpath</span> <span class="hljs-string">%.c</span> <span class="hljs-string">bar</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>其表示 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.c foo:bar<br><span class="hljs-keyword">vpath</span> %   blish<br></code></pre></td></tr></table></figure><p>而上面的语句则表示 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p><h2 id="4-伪目标"><a href="#4-伪目标" class="headerlink" title="-4- 伪目标"></a>-4- 伪目标</h2><p>前面有提到过，通常在makefile中会定义一个用于清除编译生成结果的目标clean，例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm *.o temp<br></code></pre></td></tr></table></figure><p>伪目标并不表示一个文件，它只是一个标签，就如同这里的clean一样，我们并不生成一个名为clean的文件。由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效，也就是必须输入<code>make clean</code>才能执行后面定义的命令。伪目标不能和文件名同名，否则make就会错把伪目标当作一个文件，这样伪目标就失去意义了。</p><p>这里举个例子，如果能当前文件夹中存在一个名为clean的文件，此时执行<code>make clean</code>会发生什么呢？</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202311171723215.png"></p><p>答案是什么都不会发生，因为make把clean当作了一个文件，而当前文件夹下已经存在了一个名为clean的文件，make就会认为它的任务已经完成了，输出了一个 <strong>make: “clean”已是最新</strong> 就退出了，这显然与我们设定的清除编译文件的目地不符。</p><p>那遇到这种情况我们难道除了修改伪目标名称之外就没有别的办法了吗？非也，我们可以显式的指定伪目标clean，这样的话，make就不会去管是否存在一个名为make的文件了，而是把clean当作一个完完全全的伪目标来对待</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202311171729951.png"></p><p>特殊的标记<code>.PHONY</code>用来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">.PHONY : <span class="hljs-type">clean</span><br></code></pre></td></tr></table></figure><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“最终目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">all : prog1 prog2 prog3<br>.PHONY : all<br><br>prog1 : prog1.o utils.o<br>    cc -o prog1 prog1.o utils.o<br><br>prog2 : prog2.o<br>    cc -o prog2 prog2.o<br><br>prog3 : prog3.o sort.o utils.o<br>    cc -o prog3 prog3.o sort.o utils.o<br></code></pre></td></tr></table></figure><p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 <code>.PHONY : all</code> 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p><p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : cleanall cleanobj cleandiff<br><br>cleanall : cleanobj cleandiff<br>    rm program<br><br>cleanobj :<br>    rm *.o<br><br>cleandiff :<br>    rm *.diff<br></code></pre></td></tr></table></figure><p><code>make cleanall</code>将清除所有要被清除的文件。<code>cleanobj</code>和<code>cleandiff</code>这两个伪目标有点像“子程序”的意思。我们可以输入<code>make cleanall</code> 和 <code>make cleanobj</code> 和 <code>make cleandiff</code>命令来达到清除不同种类文件的目的。</p><h2 id="5-多目标"><a href="#5-多目标" class="headerlink" title="-5- 多目标"></a>-5- 多目标</h2><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@</code> （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">bigoutput littleoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -$(subst <span class="hljs-keyword">output</span>,,$@) &gt; $@<br></code></pre></td></tr></table></figure><p>上述规则等价于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">bigoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -big &gt; bigoutput<br>littleoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -little &gt; littleoutput<br></code></pre></td></tr></table></figure><p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示目标的集合，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p><h2 id="6-静态模式"><a href="#6-静态模式" class="headerlink" title="-6- 静态模式"></a>-6- 静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br>    ...<br></code></pre></td></tr></table></figure><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p><p>target-pattern是指明了targets的模式，也就是的目标集模式。</p><p>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p><p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-pattern&gt;定义成 <code>%.o</code> ，意思是我们的&lt;target&gt;;集合中都是以 <code>.o</code> 结尾的，而如果我们的&lt;prereq-patterns&gt;定义成 <code>%.c</code> ，意思是对&lt;target-pattern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-pattern&gt;模式中的 <code>%</code> （也就是去掉了 <code>.o</code> 这个结尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p><p>所以，我们的“目标模式”或是“依赖模式”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。</p><p>看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上面的例子中，指明了我们的目标从$object中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件， <code>$@</code> 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foo<span class="hljs-selector-class">.o</span> : foo<span class="hljs-selector-class">.c</span><br>    $(CC) -c $(CFLAGS) foo<span class="hljs-selector-class">.c</span> -o foo<span class="hljs-selector-class">.o</span><br>bar<span class="hljs-selector-class">.o</span> : bar<span class="hljs-selector-class">.c</span><br>    $(CC) -c $(CFLAGS) bar<span class="hljs-selector-class">.c</span> -o bar.o<br></code></pre></td></tr></table></figure><p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">files = foo.elc bar.o lose.o<br><br>$(<span class="hljs-keyword">filter</span> %.o,$(files)): %.o: %.c<br>    $(CC) -c $(CFLAGS) $&lt; -o $@<br>$(<span class="hljs-keyword">filter</span> %.elc,$(files)): %.elc: %.el<br>    emacs -f batch-byte-compile $&lt;<br></code></pre></td></tr></table></figure><p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。其它的内容，我就不用多说了吧。这个例子展示了Makefile中更大的弹性。</p><h2 id="7-自动生成依赖"><a href="#7-自动生成依赖" class="headerlink" title="-7- 自动生成依赖"></a>-7- 自动生成依赖</h2><p>在使用大型项目时，一个源文件通常会包含很多头文件，在编写Makefile时，人工手动维护这种依赖关系是一件很容易出错的事。而C&#x2F;C++编译器提供的一项功能可以很好的解决这个问题。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -M main.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>其输出是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>编译器会自动生成的依赖关系，这样一来，就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果使用GNU的C&#x2F;C++编译器，你得用 <code>-MM</code> 参数，不然， <code>-M</code> 参数会把一些标准库的头文件也包含进来。</p><p>gcc -M main.c的输出是:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">main.o: main.c defs.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/stdio.h /u</span>sr<span class="hljs-regexp">/include/</span>features.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/sys/</span>cdefs.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/gnu/</span>stubs.h \<br>    <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc-lib/i</span>486-suse-linux<span class="hljs-regexp">/2.95.3/i</span>nclude/stddef.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>types.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>pthreadtypes.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>sched.h <span class="hljs-regexp">/usr/i</span>nclude/libio.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/_G_config.h /u</span>sr<span class="hljs-regexp">/include/</span>wchar.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>wchar.h <span class="hljs-regexp">/usr/i</span>nclude/gconv.h \<br>    <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc-lib/i</span>486-suse-linux<span class="hljs-regexp">/2.95.3/i</span>nclude/stdarg.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>stdio_lim.h<br></code></pre></td></tr></table></figure><p>gcc -MM main.c的输出则是:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main.o: main.c defs.h</span><br></code></pre></td></tr></table></figure><p>下面的问题是如何将此功能与Makefile结合起来呢，不可能让makefile本身也依赖于<code>%.c</code>，GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的Makefile文件， <code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系。</p><p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让make自动更新或生成 <code>.d</code> 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p><p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">%.d: %.c<br>    @<span class="hljs-built_in">set</span> <span class="hljs-literal">-e</span>; <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>; \<br>    <span class="hljs-variable">$</span>(CC) <span class="hljs-literal">-M</span> <span class="hljs-variable">$</span>(CPPFLAGS) <span class="hljs-variable">$</span>&lt; &gt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span>; \<br>    sed <span class="hljs-string">&#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27;</span> &lt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span> &gt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>; \<br>    <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件， <code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，也就是将<code>name.c :</code>替换为<code>name.c name.d :</code>。第四行就是删除临时文件。</p><p>这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>转成：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.d</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>这样<code>.d</code>文件也会自动更新并且生成了</p><h1 id="0x04-书写命令"><a href="#0x04-书写命令" class="headerlink" title="0x04 书写命令"></a>0x04 书写命令</h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p><p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被 <code>/bin/sh</code> ——UNIX的标准Shell 解释执行的。除非你特别指定一个其它的Shell。Makefile中， <code>#</code> 是注释符，很像C&#x2F;C++中的 <code>//</code> ，其后的本行字符都被注释。</p><h2 id="1-显示命令"><a href="#1-显示命令" class="headerlink" title="-1- 显示命令"></a>-1- 显示命令</h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">@<span class="hljs-keyword">echo</span> 正在编译XXX模块<span class="hljs-string">......</span><br></code></pre></td></tr></table></figure><p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">echo 正在编译XXX模块<span class="hljs-params">...</span><span class="hljs-params">...</span><br>正在编译XXX模块<span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>如果make执行时，带入make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p><p>而make参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</p><h2 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="-2- 命令执行"></a>-2- 命令执行</h2><p>如果需要让上一行的命令结果作用于下一行，就需要将这两个命令用分号隔开，而非将这两条命令放在两行。如：</p><ul><li>示例一：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:<br>    <span class="hljs-built_in">cd</span> /home/hchen<br>    <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><ul><li>示例二：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:<br>    <span class="hljs-built_in">cd</span> /home/hchen; <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p>当我们执行 <code>make exec</code> 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“&#x2F;home&#x2F;hchen”。</p><h2 id="3-命令出错"><a href="#3-命令出错" class="headerlink" title="-3- 命令出错"></a>-3- 命令出错</h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p><p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号 <code>-</code> （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">clean:</span><br>    -rm -f *.o<br></code></pre></td></tr></table></figure><p>如果在执行make时加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么make将会被设定为全局忽略错误，也就是make会忽略掉makefile中全部的错误。</p><p>此外，和伪目标一样，我们可以用特殊标记<code>.IGNORE</code>将目标设定为忽略错误。例如</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">.IGNORE:</span> clean<br><span class="hljs-symbol">clean:</span><br>    rm -f *.o<br></code></pre></td></tr></table></figure><p>这样，无论rm的执行正确与否，make都会忽略掉返回结果，认为是正确的。</p><p>还有一个要提一下的make的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><h2 id="4-嵌套执行make"><a href="#4-嵌套执行make" class="headerlink" title="-4- 嵌套执行make"></a>-4- 嵌套执行make</h2><p>在大型项目中，不同的功能、模块的源文件都被分类放在不同的文件夹目录下，如果将整个工程的编译规则都写在一个makefile中，会导致不便于维护，也会显得makefile过于臃肿，使用起来也不够灵活。为了解决这些问题，可以嵌套使用make，在每个模块的目录下都编写一个对应模块的makefile文件，将该模块下的编译规则、依赖信息写入对应的makefile下，然后在总的makefile中调用这些子目录下的makefile就能做到编译整个项目了。</p><p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span><br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    <span class="hljs-variable">$(MAKE)</span> -C subdir<br></code></pre></td></tr></table></figure><p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p><p>总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是<strong>不会</strong>覆盖下层的Makefile中所定义的变量，除非指定了 <code>-e</code> 参数。</p><p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">export &lt;<span class="hljs-built_in">variable</span> <span class="hljs-params">...</span>&gt;;<br></code></pre></td></tr></table></figure><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">unexport &lt;<span class="hljs-built_in">variable</span> <span class="hljs-params">...</span>&gt;;<br></code></pre></td></tr></table></figure><p>如果要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p><p>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>但是make命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> （-C 改变工作目录，-f 指定Makefile，-h 输出帮助信息，-o 指定文件不被更新，-W touch指定文件后执行），如果你不想往下层传递参数，那么，你可以这样来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span> MAKEFLAGS=<br></code></pre></td></tr></table></figure><hr><p>还有一个在“嵌套执行”中比较有用的参数， <code>-w</code> 或是 <code>--print-directory</code> 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make”，如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看到:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">make:</span> Entering directory `<span class="hljs-keyword">/home/</span>hchen<span class="hljs-keyword">/gnu/</span>make<span class="hljs-string">&#x27;.</span><br></code></pre></td></tr></table></figure><p>而在完成下层make后离开目录时，我们会看到:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">make:</span> Leaving directory `<span class="hljs-keyword">/home/</span>hchen<span class="hljs-keyword">/gnu/</span>make&#x27;<br></code></pre></td></tr></table></figure><p>当你使用 <code>-C</code> 参数来指定make下层Makefile时， <code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> （ <code>--slient</code> ）或是 <code>--no-print-directory</code> ，那么， <code>-w</code> 总是失效的。</p><h2 id="5-定义命令包"><a href="#5-定义命令包" class="headerlink" title="-5- 定义命令包"></a>-5- 定义命令包</h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 <code>define</code> 和 <code>endef</code> 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo.c : foo.y<br>    $(run-yacc)<br></code></pre></td></tr></table></figure><p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的 <code>$^</code> 就是 <code>foo.y</code> ， <code>$@</code> 就是 <code>foo.c</code> ，make在执行命令包时，命令包中的每个命令会被依次独立执行。</p><h1 id="0x05-使用变量"><a href="#0x05-使用变量" class="headerlink" title="0x05 使用变量"></a>0x05 使用变量</h1><p>这一部分，陈皓大佬写得有些冗杂，所以参考了<a href="https://www.zhaixue.cc/makefile/makefile-val.html">makefile简明教程</a>的部分。</p><p>Makefile中变量的本质有些类似于C语言中的宏定义，变量只做字符替换，在使用它的地方，变量会原封不动的展开。但是Makefile中的变量赋值使用比C语言的宏定义要更加灵活。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。</p><p>此外，<code>$&lt;</code> 、 <code>$@</code> 等是自动化变量，可以帮助我们自动执行makefile规则，使makefile更加简洁。</p><h2 id="1-变量的基础"><a href="#1-变量的基础" class="headerlink" title="-1- 变量的基础"></a>-1- 变量的基础</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果要使用真实的 <code>$</code> 字符，那么需要用 <code>$$</code> 来表示。</p><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p><p>变量会在使用它的地方精确地展开，就像C&#x2F;C++中的宏一样，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = c<br>prog.o : prog.<span class="hljs-variable">$(foo)</span><br>    <span class="hljs-variable">$(foo)</span><span class="hljs-variable">$(foo)</span> -<span class="hljs-variable">$(foo)</span> prog.<span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><p>展开后得到：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">prog.o : prog.c<br>    cc -c prog.c<br></code></pre></td></tr></table></figure><p>给变量加上括号，是为了更安全地使用变量，如果不加括号，其实也是可以使用的，但是可能会导致意料之外的情况，因此最好是在使用时加上变量。</p><h2 id="2-变量的赋值"><a href="#2-变量的赋值" class="headerlink" title="-2- 变量的赋值"></a>-2- 变量的赋值</h2><p>在Makefile中，给变量赋值一共有四种，分别代表不同的含义</p><ul><li><code>=</code> ：延迟赋值</li><li><code>:=</code>：立即赋值</li><li><code>+=</code>：追加赋值</li><li><code>?=</code>：条件赋值</li></ul><p>首先看前两种。在Makefile中，给一个变量A赋值时可以使用另外一个变量B的值。但是B变量的值在什么时候展开就区分了延迟赋值和立即赋值。看如下一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a = 1<br>b = 2<br>val_a := <span class="hljs-variable">$(a)</span><br>val_b  = <span class="hljs-variable">$(b)</span><br>a = 10<br>b = 20<br><span class="hljs-section">test:</span><br>    echo <span class="hljs-variable">$(val_a)</span><br>    echo <span class="hljs-variable">$(val_b)</span><br></code></pre></td></tr></table></figure><p>其结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1<br>1<br>echo 20<br>20<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>val_a</code>使用了立即变量，也就是在解析到该语句时，其后的<code>$(a)</code>就会立即解析出来为1，然后立即赋值给了<code>val_a</code>，也就相当于此时<code>val_a</code>的值已经锁定了。而<code>val_b</code>使用的是延迟变量，也就是<code>$(b)</code>的值在赋值时不会被解析，而是在使用时<code>echo $(val_b)</code>解析，此时的<code>$(b)</code>的值为20，所以此时<code>val_b</code>的值为20。</p><blockquote><p>在make执行的过程中，在进入规则开始执行之前，make会先解析变量的值，确定一个最终值，这些都会发生在执行规则命令之前，这一点和宏定义很像，可以视作预编译的过程。</p><p>在make命令执行的过程中，变量值一般是不会更改的。在 Makefile 中，每个规则的执行都在一个子 Shell 中完成，这意味着在规则中对变量的更改不会影响到父 Shell 或其他规则。——来自ChatGPT</p></blockquote><p>这两种赋值方式各有优劣，延迟赋值可以把变量的真实值推到后面来定义，但是可能造成嵌套定义的灾难；而立即赋值更接近C语言中宏定义的使用，遵循先定义后使用的规则，但是，在makefile中，使用未定义的变量来立即赋值不会报错，而是会直接忽视未定义的变量。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">y := <span class="hljs-variable">$(x)</span> bar<br>x := foo<br></code></pre></td></tr></table></figure><p>那么，y的值是bar，而不是foo bar。</p><hr><p>再看后面两种赋值方式。追加赋值就是在原本的变量的基础上加上一部分，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o foo.o bar.o utils.o<br>objects += another.o<br></code></pre></td></tr></table></figure><p><code>$(objects)</code> 值变成：<code>main.o foo.o bar.o utils.o another.o</code></p><p>如果变量之前没有定义过，那么， <code>+=</code> 会自动变成 <code>=</code> ，如果前面有变量定义，那么 <code>+=</code> 会继承于前次操作的赋值符。如果前一次的是 <code>:=</code> ，那么 <code>+=</code> 会以 <code>:=</code> 作为其赋值符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable += more<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">variable := value<br>variable := <span class="hljs-variable">$(variable)</span> more<br></code></pre></td></tr></table></figure><p>还有一个赋值方式是条件赋值<code>?=</code>，它的含义是如果被赋值的变量之前未被赋值过，那么就将其赋值，如果被赋值变量此前已经被赋值过了，那就什么都不做。值得注意的时，条件赋值<code>?=</code>执行赋值时等价于延迟赋值<code>=</code>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">FOO ?= bar<br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">origin</span> FOO)</span>, undefined)<br>    FOO = bar<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>在变量赋值时要注意的是注释符<code>#</code>的使用，<code>#</code>可以用来标识变量定义的终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">nullstring :=<br>space := <span class="hljs-variable">$(nullstring)</span> <span class="hljs-comment"># end of the line</span><br></code></pre></td></tr></table></figure><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dir := /foo/bar    <span class="hljs-comment"># directory to put the frobs in</span><br></code></pre></td></tr></table></figure><p>dir这个变量的值是“&#x2F;foo&#x2F;bar”，后面还跟了4个空格，如果我们这样使用这个变量来指定别的目录——“$(dir)&#x2F;file”那么就完蛋了。</p></blockquote><h2 id="3-多行变量"><a href="#3-多行变量" class="headerlink" title="-3- 多行变量"></a>-3- 多行变量</h2><p>使用define关键字可以定义多行变量，多行变量的值可以包含换行符，使用endef关键字标识多行变量定义的结束。若多行变量的值不是以TAB键开头，那么就不会被make认为是命令，所以前面的命令包的就是一种使用多行变量的例子。</p><p>多行变量的格式如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> 变量名<br>变量值<br>...<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>多行变量的赋值规则与<code>=</code>一样，也就是在使用此多行变量时才会展开</p><h2 id="4-override指令"><a href="#4-override指令" class="headerlink" title="-4- override指令"></a>-4- override指令</h2><p>如果有变量是由make命令行参数传入的，这些变量默认会屏蔽Makefile中的同名变量。如果要更改这些变量值，就需要使用override命令。其规则如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;<br><br><span class="hljs-keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;<br><br><span class="hljs-keyword">override</span> &lt;variable&gt;; += &lt;more text&gt;;<br></code></pre></td></tr></table></figure><p>对于多行变量的定义，同样可以使用override指令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> <span class="hljs-keyword">define</span> foo<br>bar<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h2 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="-5- 环境变量"></a>-5- 环境变量</h2><p>make 运行时，系统的环境变量可以载入到Makefile文件中，但是如果该变量已经在Makefile中被定义了或是由make命令行参数引入了，那么系统的环境变量将会被屏蔽。（如果make指定了<code>-e</code>|<code>--environment-overrides</code>参数，那么，系统环境变量将覆盖Makefile中定义的变量）。Makefile中定义的变量和系统环境变量之间的关系 就类似于 局部变量和全局变量之间的关系 </p><p><strong>变量优先级：make命令行参数变量 &gt; makefile自定义变量 &gt; 系统环境变量</strong></p><p>在make嵌套使用时，上层的Makefike中的自定义变量（用export指明的）会以系统环境变量的方式传入到下层的Makefile中。（默认情况下，只有make命令行参数变量会被传递）</p><h2 id="6-变量替换"><a href="#6-变量替换" class="headerlink" title="-6- 变量替换"></a>-6- 变量替换</h2><p>变量替换有两种模式，一种是替换指定字符串，另一种是模式替换。</p><p><strong>第一种替换指定后缀字符串</strong></p><p>先看如下的例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>SRC := main.c sub.c<br>OBJ := $(SRC:.c=.o)<br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;SRC = <span class="hljs-variable">$(SRC)</span>&quot;</span><br>@echo <span class="hljs-string">&quot;OBJ = <span class="hljs-variable">$(OBJ)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>执行make命令，运行结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">SRC = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span><br>OBJ = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> sub.o<br></code></pre></td></tr></table></figure><p><code>$(SRC:.c=.o)</code>就实现了后缀字符串的替换，其含义为用<code>.o</code>替换掉原本的<code>.c</code>。所以，后缀字符串替换的规则格式如下</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(变量名:将要被替换的字符串=想用来被替换的字符串）<br></code></pre></td></tr></table></figure><p>值得注意的是，使用这种方法只能替换掉后缀字符串。</p><hr><p><strong>第二种模式替换</strong></p><p>使用 <code>% </code>保留变量值中的指定字符，替换其他字符。给出如下的例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>SRC := main.c sub.c<br>OBJ := $(SRC:%.c=%.o)<br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;SRC = <span class="hljs-variable">$(SRC)</span>&quot;</span>    <br>@echo <span class="hljs-string">&quot;OBJ = <span class="hljs-variable">$(OBJ)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>执行make命令，运行结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">SRC = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span><br>OBJ = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> sub.o<br></code></pre></td></tr></table></figure><h2 id="7-自动化变量"><a href="#7-自动化变量" class="headerlink" title="-7- 自动化变量"></a>-7- 自动化变量</h2><p>在《跟我一起写Makefile》中，自动化变量的内容被放在了隐含变量-隐含规则链中，我这里就放在其他变量一起了。</p><p>自动化变量是为了简化编译命令而生的，对于那些使用模式规则编写的Makefile，使用自动化变量就能使用一个shell命令完成编译任务。举个例子：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">%.o : %.c<br>    $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br></code></pre></td></tr></table></figure><p>在这个示例中，模式规则设定了目标是所有以.o结尾的目标文件，而依赖是对应的.c源文件，对于这种模式规则，在编写命令时就需要使用到自动化变量来表示对应的目标和依赖了，其中<code>$&lt;</code>表示的是依次取出的依赖文件，而<code>$@</code>表示依次取出的目标文件。</p><p>以下是常见的自动化变量的含义</p><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ，那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件（Unix下是 <code>.a</code> ，Windows下是 <code>.lib</code> ），那么，其值为空。</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li><li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/foo</code> 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是make所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code>$*</code> 就是空值。</li></ul><p>在上述所列出来的自动量变量中。四个变量（ <code>$@</code> 、 <code>$&lt;</code> 、 <code>$%</code> 、 <code>$*</code> ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 <code>D</code> 或 <code>F</code> 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 <code>dir</code> 或 <code>notdir</code> 就可以做到了。 <code>D</code> 的含义就是Directory，就是目录， <code>F</code> 的含义就是File，就是文件。</p><p>下面是对于上面的七个变量分别加上 <code>D</code> 或是 <code>F</code> 的含义：</p><ul><li><p><code>$(@D)</code></p><p>表示 <code>$@</code> 的目录部分（不以斜杠作为结尾），如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而如果 <code>$@</code> 中没有包含斜杠的话，其值就是 <code>.</code> （当前目录）。</p></li><li><p><code>$(@F)</code></p><p>表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是 <code>foo.o</code> ， <code>$(@F)</code> 相当于函数 <code>$(notdir $@)</code> 。</p></li><li><p><code>$(*D)</code>, <code>$(*F)</code></p><p>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， <code>$(*D)</code> 返回 <code>dir</code> ，而 <code>$(*F)</code> 返回 <code>foo</code></p></li><li><p><code>$(%D)</code>, <code>$(%F)</code></p><p>分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code>archive(member)</code> 形式的目标中的 <code>member</code> 中包含了不同的目录很有用。</p></li><li><p><code>$(&lt;D)</code>, <code>$(&lt;F)</code></p><p>分别表示依赖文件的目录部分和文件部分。</p></li><li><p><code>$(^D)</code>, <code>$(^F)</code></p><p>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p></li><li><p><code>$(+D)</code>, <code>$(+F)</code></p><p>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p></li><li><p><code>$(?D)</code>, <code>$(?F)</code></p><p>分别表示被更新的依赖文件的目录部分和文件部分。</p></li></ul><h2 id="8-目标变量"><a href="#8-目标变量" class="headerlink" title="-8- 目标变量"></a>-8- 目标变量</h2><p>前面提过Makefile中自定义的变量与环境变量的关系类似于局部变量屏蔽全局变量的关系。那么，在Makefile文件中，是否还有更加局部的变量呢？答案是有的。我们知道在Makefile文件中定义的变量在整个文件中都可以使用，但是如果定义了目标变量，那么在此目标的规则中就可以使用同名的目标变量来屏蔽先前定义的全局变量了。</p><p>其语法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">...</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">...</span>&gt;</span> : overide <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式，如 <code>=</code> 、 <code>:=</code> 、 <code>+=</code> 或是 <code>?=</code> 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">prog : CFLAGS = -g<br>prog : prog<span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span><br>    $(CC) $(CFLAGS) prog<span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span><br><br>prog<span class="hljs-selector-class">.o</span> : prog<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) prog<span class="hljs-selector-class">.c</span><br><br>foo<span class="hljs-selector-class">.o</span> : foo<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) foo<span class="hljs-selector-class">.c</span><br><br>bar<span class="hljs-selector-class">.o</span> : bar<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure><p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code></p><h2 id="9-模式变量"><a href="#9-模式变量" class="headerlink" title="-9- 模式变量"></a>-9- 模式变量</h2><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p><p>我们知道，make的“模式”一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code> 结尾的目标定义目标变量：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@<br><br>%.o : CFLAGS = -O<br></code></pre></td></tr></table></figure><p>同样，模式变量的语法和“目标变量”一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">...</span>&gt;</span>; : <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">...</span>&gt;</span>; : override <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p><h1 id="0x06-使用条件判断"><a href="#0x06-使用条件判断" class="headerlink" title="0x06 使用条件判断"></a>0x06 使用条件判断</h1><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。在Makefile中，可以使用ifeq、ifneq、ifdef、ifndef 等关键字来进行条件判断。</p><p>先看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">libs_for_gcc = -lgnu<br>normal_libs =<br><br><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>在这个示例中，根据$(CC)变量的值，会选择不同的库来完成编译。其中<code>ifeq</code> 、 <code>else</code> 和 <code>endif</code>是条件判断的关键字。 <code>ifeq</code> 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 <code>else</code> 表示条件表达式为假的情况。 <code>endif</code> 表示一个条件语句的结束，任何一个条件表达式都应该以 <code>endif</code> 结束。</p><p>当我们的变量 <code>$(CC)</code> 值是 <code>gcc</code> 时，目标 <code>foo</code> 的规则是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br></code></pre></td></tr></table></figure><p>而当我们的变量 <code>$(CC)</code> 值不是 <code>gcc</code> 时（比如 <code>cc</code> ），目标 <code>foo</code> 的规则是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">foo: <span class="hljs-variable">$(objects)</span></span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(normal_libs)</span><br></code></pre></td></tr></table></figure><p>由此可以得出条件判断的语法规则：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;conditional-directive&gt;</span><br><span class="hljs-symbol">&lt;text-if-true&gt;</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>以及:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;conditional-directive&gt;<br>&lt;<span class="hljs-built_in">text</span>-<span class="hljs-keyword">if</span>-<span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">else</span><br>&lt;<span class="hljs-built_in">text</span>-<span class="hljs-keyword">if</span>-<span class="hljs-literal">false</span>&gt;<br>endif<br></code></pre></td></tr></table></figure><p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，一共有四个： <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code></p><h2 id="1-ifeq-ifneq"><a href="#1-ifeq-ifneq" class="headerlink" title="-1- ifeq &amp; ifneq"></a>-1- ifeq &amp; ifneq</h2><p><code>ifeq</code>就是比较两个参数的值是否相等，如果相等则为真，否则为假。<code>ifeq</code>后面的参数有多种写法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">ife<span class="hljs-string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span><br>ifeq <span class="hljs-string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="hljs-string">&#x27;&lt;arg2&gt;&#x27;</span><br>ifeq <span class="hljs-string">&quot;&lt;arg1&gt;&quot;</span> <span class="hljs-string">&quot;&lt;arg2&gt;&quot;</span><br>ifeq <span class="hljs-string">&quot;&lt;arg1&gt;&quot;</span> <span class="hljs-string">&#x27;&lt;arg2&gt;&#x27;</span><br>ifeq <span class="hljs-string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="hljs-string">&quot;&lt;arg2&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>参数中还可以使用make的函数。如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(foo)</span>)</span>,)<br>&lt;text-if-empty&gt;<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>这个示例中使用了 <code>strip</code> 函数，如果这个函数的返回值是空（Empty），那么 <code>&lt;text-if-empty&gt;</code> 就生效。</p><p><code>ifneq</code>就是比较两个参数的值是否不相等，如果不相等则为真，否则为假。这就于<code>ifeq</code>刚好相反，不过多赘述。</p><h2 id="2-ifdef-ifndef"><a href="#2-ifdef-ifndef" class="headerlink" title="-2- ifdef &amp; ifndef"></a>-2- ifdef &amp; ifndef</h2><p>语法规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ifdef <span class="hljs-tag">&lt;<span class="hljs-name">variable-name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真。否则，表达式为假。当然， <code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值。注意， <code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p><p>示例一：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar =<br>foo = <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">ifdef</span> foo<br>    frobozz = yes<br><span class="hljs-keyword">else</span><br>    frobozz = no<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">foo</span> <span class="hljs-operator">=</span><br>ifdef foo<br>    frobozz <span class="hljs-operator">=</span> yes<br>else<br>    frobozz <span class="hljs-operator">=</span> no<br>endif<br></code></pre></td></tr></table></figure><p>第一个例子中， <code>$(frobozz)</code> 值是 <code>yes</code> ，第二个则是 <code>no</code>。</p><p><code>ifndef</code>也是类似的，只是含义恰好相反，也不赘述了。</p><p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p><h1 id="0x07-使用函数"><a href="#0x07-使用函数" class="headerlink" title="0x07 使用函数"></a>0x07 使用函数</h1><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p><h2 id="1-函数的调用语法"><a href="#1-函数的调用语法" class="headerlink" title="-1- 函数的调用语法"></a>-1- 函数的调用语法</h2><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(&lt;<span class="hljs-keyword">function</span>&gt; &lt;<span class="hljs-variable language_">arguments</span>&gt;)<br>or<br>$&#123;&lt;<span class="hljs-keyword">function</span>&gt; &lt;<span class="hljs-variable language_">arguments</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>这里， <code>&lt;function&gt;</code> 就是函数名，make支持的函数不多。 <code>&lt;arguments&gt;</code> 为函数的参数，<strong>参数间以逗号 <code>,</code> 分隔，而函数名和参数之间以“空格”分隔</strong>。函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">comma:= ,<br>empty:=<br>space:= <span class="hljs-variable">$(empty)</span> <span class="hljs-variable">$(empty)</span><br>foo:= a b c<br>bar:= <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(space)</span>,<span class="hljs-variable">$(comma)</span>,<span class="hljs-variable">$(foo)</span>)</span><br></code></pre></td></tr></table></figure><p>在这个示例中， <code>$(comma)</code> 的值是一个逗号。 <code>$(space)</code> 使用了 <code>$(empty)</code> 定义了一个空格， <code>$(foo)</code> 的值是 <code>a b c</code> ， <code>$(bar)</code> 的定义用，调用了函数 <code>subst</code> ，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把 <code>$(foo)</code> 中的空格替换成逗号，所以 <code>$(bar)</code> 的值是 <code>a,b,c</code> 。</p><h2 id="2-字符串处理函数"><a href="#2-字符串处理函数" class="headerlink" title="-2- 字符串处理函数"></a>-2- 字符串处理函数</h2><h3 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$(subst &lt;<span class="hljs-keyword">from</span>&gt;,&lt;<span class="hljs-keyword">to</span>&gt;,&lt;<span class="hljs-built_in">text</span>&gt;)<br></code></pre></td></tr></table></figure><ul><li><p>名称：字符串替换函数</p></li><li><p>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code> 。</p></li><li><p>返回：函数返回被替换过后的字符串。</p></li><li><p>示例：</p><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$(subst ee,EE,feet on the street)<br><br>把 `feet on the street` 中的 `ee` 替换成 `EE` ，返回结果是 `fEEt on the strEEt` 。<br><br><br><br>### patsubst<br><br></code></pre></td></tr></table></figure></blockquote></li></ul><p>$(patsubst <pattern>,<replacement>,<text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：模式字符串替换函数。<br><br>- 功能：查找 `&lt;text&gt;` 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 `&lt;pattern&gt;` ，如果匹配的话，则以 `&lt;replacement&gt;` 替换。这里， `&lt;pattern&gt;` 可以包括通配符 `%` ，表示任意长度的字串。如果 `&lt;replacement&gt;` 中也包含 `%` ，那么， `&lt;replacement&gt;` 中的这个 `%` 将是 `&lt;pattern&gt;` 中的那个 `%` 所代表的字串。（可以用 `\` 来转义，以 `\%` 来表示真实含义的 `%` 字符）<br><br>- 返回：函数返回被替换过后的字符串。<br><br>- 示例：<br><br></code></pre></td></tr></table></figure><blockquote><p>$(patsubst %.c,%.o,x.c.c bar.c)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>把字串 `x.c.c bar.c` 符合模式 `%.c` 的单词替换成 `%.o` ，返回结果是 `x.c.o bar.o`<br><br><br><br>### strip<br><br></code></pre></td></tr></table></figure><p>$(strip <string>)</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：去空格函数。<br><br><span class="hljs-bullet">-</span> 功能：去掉 <span class="hljs-code">`&lt;string&gt;`</span> 字串中开头和结尾的空字符。<br><br><span class="hljs-bullet">-</span> 返回：返回被去掉空格的字符串值。<br><br><span class="hljs-bullet">-</span> 示例：<br><br></code></pre></td></tr></table></figure><blockquote><p>$(strip a b c )</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br> 把字串 `a b c ` 去掉开头和结尾的空格，结果是 `a b c`。<br><br><br><br>### findstring<br><br></code></pre></td></tr></table></figure><p>$(findstring <find>,<in>)</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：查找字符串函数<br><br><span class="hljs-bullet">-</span> 功能：在字串 <span class="hljs-code">`&lt;in&gt;`</span> 中查找 <span class="hljs-code">`&lt;find&gt;`</span> 字串。<br><br><span class="hljs-bullet">-</span> 返回：如果找到，那么返回 <span class="hljs-code">`&lt;find&gt;`</span> ，否则返回空字符串。<br><br><span class="hljs-bullet">-</span> 示例：<br><br></code></pre></td></tr></table></figure><blockquote><p>$(findstring a,a b c)<br>$(findstring a,b c)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>第一个函数返回 `a` 字符串，第二个返回空字符串<br><br><br><br>### filter<br><br></code></pre></td></tr></table></figure><p>$(filter &lt;pattern…&gt;,<text>)</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：过滤函数<br><br>- 功能：以 `&lt;pattern&gt;` 模式过滤 `&lt;text&gt;` 字符串中的单词，保留符合模式 `&lt;pattern&gt;` 的单词。可以有多个模式。<br><br>- 返回：返回符合模式 `&lt;pattern&gt;` 的字串。<br><br>- 示例：<br><br></code></pre></td></tr></table></figure><blockquote><p>sources :&#x3D; foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>    cc $(filter %.c %.s,$(sources)) -o foo</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br> `$(<span class="hljs-keyword">filter</span> <span class="hljs-variable">%.c</span> <span class="hljs-variable">%.s</span><span class="hljs-punctuation">,</span>$(sources))` 返回的值是 `foo.<span class="hljs-keyword">c</span> bar.<span class="hljs-keyword">c</span> baz.s` 。<br><br><br><br>### <span class="hljs-keyword">filter</span>-out<br><br></code></pre></td></tr></table></figure><p>$(filter-out &lt;pattern…&gt;,<text>)</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：反过滤函数<br><br>- 功能：以 `&lt;pattern&gt;` 模式过滤 `&lt;text&gt;` 字符串中的单词，去除符合模式 `&lt;pattern&gt;` 的单词。可以有多个模式。<br><br>- 返回：返回不符合模式 `&lt;pattern&gt;` 的字串。<br><br>- 示例：<br><br></code></pre></td></tr></table></figure><blockquote><p>objects&#x3D;main1.o foo.o main2.o bar.o<br>mains&#x3D;main1.o main2.o</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs julia"><br> <span class="hljs-string">`<span class="hljs-subst">$(filter-out $(mains)</span>,<span class="hljs-subst">$(objects)</span>)`</span> 返回值是 <span class="hljs-string">`foo.o bar.o`</span> 。<br><br><br><br><span class="hljs-comment">### sort </span><br><br></code></pre></td></tr></table></figure><p>$(sort <list>)</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：排序函数<br><span class="hljs-bullet">-</span> 功能：给字符串 <span class="hljs-code">`&lt;list&gt;`</span> 中的单词排序（升序）。<br><span class="hljs-bullet">-</span> 返回：返回排序后的字符串。<br><span class="hljs-bullet">-</span> 示例： <span class="hljs-code">`$(sort foo bar lose)`</span> 返回 <span class="hljs-code">`bar foo lose`</span> 。<br><span class="hljs-bullet">-</span> 备注： <span class="hljs-code">`sort`</span> 函数会去掉 <span class="hljs-code">`&lt;list&gt;`</span> 中相同的单词。<br><br><br><br><span class="hljs-section">### word</span><br><br></code></pre></td></tr></table></figure><p>$(word <n>,<text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：取单词函数<br>- 功能：取字符串 `&lt;text&gt;` 中第 `&lt;n&gt;` 个单词。（从一开始）<br>- 返回：返回字符串 `&lt;text&gt;` 中第 `&lt;n&gt;` 个单词。如果 `&lt;n&gt;` 比 `&lt;text&gt;` 中的单词数要大，那么返回空字符串。<br>- 示例： `$(word <span class="hljs-number">2</span>, foo bar baz)` 返回值是 `bar` 。<br><br><br><br>### wordlist<br><br></code></pre></td></tr></table></figure><p>$(wordlist <ss>,<e>,<text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：取单词串函数<br>- 功能：从字符串 `&lt;text&gt;` 中取从 `&lt;ss&gt;` 开始到 `&lt;e&gt;` 的单词串。 `&lt;ss&gt;` 和 `&lt;e&gt;` 是一个数字。<br>- 返回：返回字符串 `&lt;text&gt;` 中从 `&lt;ss&gt;` 到 `&lt;e&gt;` 的单词字串。如果 `&lt;ss&gt;` 比 `&lt;text&gt;` 中的单词数要大，那么返回空字符串。如果 `&lt;e&gt;` 大于 `&lt;text&gt;` 的单词数，那么返回从 `&lt;ss&gt;` 开始，到 `&lt;text&gt;` 结束的单词串。<br>- 示例： `$(wordlist <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, foo bar baz)` 返回值是 `bar baz` 。<br><br><br><br>### words<br><br></code></pre></td></tr></table></figure><p>$(words <text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：单词个数统计函数<br>- 功能：统计 `&lt;text&gt;` 中字符串中的单词个数。<br>- 返回：返回 `&lt;text&gt;` 中的单词数。<br>- 示例： `$(words, foo bar baz)` 返回值是 `3` 。<br>- 备注：如果我们要取 `&lt;text&gt;` 中最后的一个单词，我们可以这样： `$(word $(words &lt;text&gt;),&lt;text&gt;)` 。<br><br><br><br>### firstword<br><br></code></pre></td></tr></table></figure><p>$(firstword <text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：首单词函数——firstword。<br>- 功能：取字符串 `&lt;text&gt;` 中的第一个单词。<br>- 返回：返回字符串 `&lt;text&gt;` 的第一个单词。<br>- 示例： `$(firstword foo bar)` 返回值是 `foo`。<br>- 备注：这个函数可以用 `word` 函数来实现： `$(word <span class="hljs-number">1</span>,&lt;text&gt;)` <br><br><br><br>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 `VPATH` 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 `CFLAGS` ，如：<br><br></code></pre></td></tr></table></figure><p>override CFLAGS +&#x3D; $(patsubst %,-I%,$(subst :, ,$(VPATH)))</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs julia"><br>如果我们的 <span class="hljs-string">`<span class="hljs-subst">$(VPATH)</span>`</span> 值是 <span class="hljs-string">`src:../headers`</span> ，那么 <span class="hljs-string">`<span class="hljs-subst">$(patsubst %,-I%,$(subst :, ,$(VPATH)</span>))`</span> 将返回 <span class="hljs-string">`-Isrc -I../headers`</span> ，这正是cc或gcc搜索头文件路径的参数。<br><br><br><br><br><br><span class="hljs-comment">## -3- 文件名操作函数</span><br><br>这些函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。<br><br><span class="hljs-comment">### dir</span><br><br></code></pre></td></tr></table></figure><p>$(dir &lt;names…&gt;)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：取目录函数——dir。<br>- 功能：从文件名序列 `&lt;names&gt;` 中取出目录部分。目录部分是指最后一个反斜杠（ `/` ）之前的部分。如果没有反斜杠，那么返回 `./` 。<br>- 返回：返回文件名序列 `&lt;names&gt;` 的目录部分。<br>- 示例： `$(dir src/foo.c hacks)` 返回值是 `src/ ./` 。<br><br><br><br>### notdir<br><br></code></pre></td></tr></table></figure><p>$(notdir &lt;names…&gt;)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：取文件函数——notdir。<br>- 功能：从文件名序列 `&lt;names&gt;` 中取出非目录部分。非目录部分是指最後一个反斜杠（ `/` ）之后的部分。<br>- 返回：返回文件名序列 `&lt;names&gt;` 的非目录部分。<br><span class="hljs-title">- 示例:</span> `$(notdir src/foo.c hacks)` 返回值是 `foo.c hacks` 。<br><br><br><br>### suffix<br><br></code></pre></td></tr></table></figure><p>$(suffix &lt;names…&gt;)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：取後缀函数——suffix。<br><span class="hljs-bullet">-</span> 功能：从文件名序列 <span class="hljs-code">`&lt;names&gt;`</span> 中取出各个文件名的后缀。<br><span class="hljs-bullet">-</span> 返回：返回文件名序列 <span class="hljs-code">`&lt;names&gt;`</span> 的后缀序列，如果文件没有后缀，则返回空字串。<br><span class="hljs-bullet">-</span> 示例： <span class="hljs-code">`$(suffix src/foo.c src-1.0/bar.c hacks)`</span> 返回值是 <span class="hljs-code">`.c .c`</span>。<br><br><br><br><span class="hljs-section">### basename</span><br><br></code></pre></td></tr></table></figure><p>$(basename &lt;names…&gt;)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：取前缀函数——basename。<br><span class="hljs-bullet">-</span> 功能：从文件名序列 <span class="hljs-code">`&lt;names&gt;`</span> 中取出各个文件名的前缀部分。<br><span class="hljs-bullet">-</span> 返回：返回文件名序列 <span class="hljs-code">`&lt;names&gt;`</span> 的前缀序列，如果文件没有前缀，则返回空字串。<br><span class="hljs-bullet">-</span> 示例： <span class="hljs-code">`$(basename src/foo.c src-1.0/bar.c hacks)`</span> 返回值是 <span class="hljs-code">`src/foo src-1.0/bar hacks`</span> 。<br><br><br><br><span class="hljs-section">### addsuffix</span><br><br></code></pre></td></tr></table></figure><p>$(addsuffix <suffix>,&lt;names…&gt;)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：加后缀函数——addsuffix。<br><span class="hljs-bullet">-</span> 功能：把后缀 <span class="hljs-code">`&lt;suffix&gt;`</span> 加到 <span class="hljs-code">`&lt;names&gt;`</span> 中的每个单词后面。<br><span class="hljs-bullet">-</span> 返回：返回加过后缀的文件名序列。<br><span class="hljs-bullet">-</span> 示例： <span class="hljs-code">`$(addsuffix .c,foo bar)`</span> 返回值是 <span class="hljs-code">`foo.c bar.c`</span> 。<br><br><br><br><span class="hljs-section">### addprefix</span><br><br></code></pre></td></tr></table></figure><p>$(addprefix <prefix>,&lt;names…&gt;)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 名称：加前缀函数——addprefix。<br><span class="hljs-bullet">-</span> 功能：把前缀 <span class="hljs-code">`&lt;prefix&gt;`</span> 加到 <span class="hljs-code">`&lt;names&gt;`</span> 中的每个单词前面。<br><span class="hljs-bullet">-</span> 返回：返回加过前缀的文件名序列。<br><span class="hljs-bullet">-</span> 示例： <span class="hljs-code">`$(addprefix src/,foo bar)`</span> 返回值是 <span class="hljs-code">`src/foo src/bar`</span> 。<br><br><br><br><span class="hljs-section">### join</span><br><br></code></pre></td></tr></table></figure><p>$(join <list1>,<list2>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 名称：连接函数——join。<br>- 功能：把 `&lt;list2&gt;` 中的单词对应地加到 `&lt;list1&gt;` 的单词后面。如果 `&lt;list1&gt;` 的单词个数要比 `&lt;list2&gt;` 的多，那么， `&lt;list1&gt;` 中的多出来的单词将保持原样。如果 `&lt;list2&gt;` 的单词个数要比 `&lt;list1&gt;` 多，那么， `&lt;list2&gt;` 多出来的单词将被复制到 `&lt;list1&gt;` 中。<br>- 返回：返回连接过后的字符串。<br>- 示例： `$(join aaa bbb , <span class="hljs-number">111</span> <span class="hljs-number">222</span> <span class="hljs-number">333</span>)` 返回值是 `aaa111 bbb222 <span class="hljs-number">333</span>` 。<br><br><br><br>## -<span class="hljs-number">4</span>- foreach 函数<br><br>foreach是一个用于循环的函数，它的语法规则：<br><br></code></pre></td></tr></table></figure><p>$(foreach <var>,<list>,<text>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>这个函数的意思是，把参数 `&lt;list&gt;` 中的单词逐一取出放到参数 `&lt;var&gt;` 所指定的变量中，然后再执行 `&lt;text&gt;` 所包含的表达式。每一次 `&lt;text&gt;` 会返回一个字符串，循环过程中， `&lt;text&gt;` 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， `&lt;text&gt;` 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。<br><br>所以， `&lt;var&gt;` 最好是一个变量名， `&lt;list&gt;` 可以是一个表达式，而 `&lt;text&gt;` 中一般会使用 `&lt;var&gt;` 这个参数来依次枚举 `&lt;list&gt;` 中的单词。举个例子：<br><br></code></pre></td></tr></table></figure><p>names :&#x3D; a b c d</p><p>files :&#x3D; $(foreach n,$(names),$(n).o)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>上面的例子中， `$(name)` 中的单词会被挨个取出，并存到变量 `n` 中， `$(n).o` 每次根据 `$(n)` 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， `$(files)` 的值是 `a.o b.o c.o d.o` 。<br><br>注意，foreach中的 `&lt;var&gt;` 参数是一个临时的局部变量，foreach函数执行完后，参数 `&lt;var&gt;` 的变量将不在作用，其作用域只在foreach函数当中。<br><br><br><br>## -<span class="hljs-number">5</span>- if函数<br><br>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br><br></code></pre></td></tr></table></figure><p>$(if <condition>,<then-part>)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>或是<br><br></code></pre></td></tr></table></figure><p>$(if <condition>,<then-part>,<else-part>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。 `&lt;condition&gt;` 参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， `&lt;then-part&gt;` 会被计算，否则 `&lt;else-part&gt;` 会被计算。<br><br>而if函数的返回值是，如果 `&lt;condition&gt;` 为真（非空字符串），那个 `&lt;then-part&gt;` 会是整个函数的返回值，如果 `&lt;condition&gt;` 为假（空字符串），那么 `&lt;else-part&gt;` 会是整个函数的返回值，此时如果 `&lt;else-part&gt;` 没有被定义，那么，整个函数返回空字串。<br><br>所以， `&lt;then-part&gt;` 和 `&lt;else-part&gt;` 只会有一个被计算。<br><br>举个例子：<br><br></code></pre></td></tr></table></figure><h1 id="定义一个变量"><a href="#定义一个变量" class="headerlink" title="定义一个变量"></a>定义一个变量</h1><p>DEBUG &#x3D; 1</p><h1 id="使用-if-函数进行条件判断"><a href="#使用-if-函数进行条件判断" class="headerlink" title="使用 if 函数进行条件判断"></a>使用 if 函数进行条件判断</h1><p>CFLAGS &#x3D; $(if $(filter 1,$(DEBUG)),-g -Wall,-O2)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>在这个例子中，`CFLAGS`的值会更具`DEBUG`变量的值来选择，如果其值为<span class="hljs-number">1</span>，则会选择`-g -Wall`，否则会选择`-O2`。<br><br><br><br>## -<span class="hljs-number">6</span>- call函数<br><br>call函数可以调用你自定义的参数化函数，你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。它的语法是：<br><br></code></pre></td></tr></table></figure><p>$(call <function-name>,<parm1>,<parm2>,…,<parmn>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>当执行这个函数时，会把参数 `&lt;parm1&gt;` 、 `&lt;parm2&gt;` 、 `&lt;parm3&gt;` 依次传入自定义的函数中的变量，最后的自定义函数返回值就是call函数的返回值。关于这个自定义函数，其变量通常用`$(<span class="hljs-number">1</span>)` `$(<span class="hljs-number">2</span>)` `$(<span class="hljs-number">3</span>)`(以此类推)来表示传入的第<span class="hljs-number">1</span>个、第<span class="hljs-number">2</span>个、第<span class="hljs-number">3</span>个参数。举个例子更好理解<br><br></code></pre></td></tr></table></figure><h1 id="定义一个简单的函数，用于连接两个字符串"><a href="#定义一个简单的函数，用于连接两个字符串" class="headerlink" title="定义一个简单的函数，用于连接两个字符串"></a>定义一个简单的函数，用于连接两个字符串</h1><p>concat &#x3D; $(1)$(2)</p><h1 id="使用-call-函数调用定义的函数"><a href="#使用-call-函数调用定义的函数" class="headerlink" title="使用 call 函数调用定义的函数"></a>使用 call 函数调用定义的函数</h1><p>result :&#x3D; $(call concat, Hello, World)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>在这个例子中，concat就是一个我们自定义的简单函数，它接受两个参数`$(<span class="hljs-number">1</span>)` 和`$(<span class="hljs-number">2</span>)`，并把它们按顺序连起来。所以最终如result的结果是`HelloWorld`<br><br>再举个例子<br><br></code></pre></td></tr></table></figure><p>reverse &#x3D;  $(2) $(1)</p><p>foo &#x3D; $(call reverse,a,b)</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><br>此时的 <span class="hljs-string">`foo`</span> 的值就是 <span class="hljs-string">`b a`</span> 。<br><br>需要注意：在向 <span class="hljs-keyword">call</span> 函数传递参数时要尤其注意空格的使用。<span class="hljs-keyword">call</span> 函数在处理参数时，第<span class="hljs-number">2</span>个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向<span class="hljs-keyword">call</span>函数提供参数时，最安全的做法是去除所有多余的空格。<br><br><br><br><span class="hljs-comment">## -7- origin函数</span><br><br>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br><br></code></pre></td></tr></table></figure><p>$(origin <variable>)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">注意， `&lt;variable&gt;` 是变量的名字，不应该是引用。所以你最好不要在 `&lt;variable&gt;` 中使用`$` 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</span><br><br>- `undefined`<br><br>  如果 `&lt;variable&gt;` 从来没有定义过，origin函数返回这个值 `undefined`<br><br>- `default`<br><br>  如果 `&lt;variable&gt;` 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。<br><br>- `environment`<br><br>  如果 `&lt;variable&gt;` 是一个环境变量，并且当Makefile被执行时， `-e` 参数没有被打开。<br><br>- `file`<br><br>  如果 `&lt;variable&gt;` 这个变量被定义在Makefile中。<br><br>- `command line`<br><br>  如果 `&lt;variable&gt;` 这个变量是被命令行定义的。<br><br>- `override`<br><br>  如果 `&lt;variable&gt;` 是被override指示符重新定义的。<br><br>- `automatic`<br><br>  如果 `&lt;variable&gt;` 是一个命令运行中的自动化变量。关于自动化变量将在前面介绍过了。<br><br>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：<br><br></code></pre></td></tr></table></figure><p>ifdef bletch<br>    ifeq “$(origin bletch)” “environment”<br>        bletch &#x3D; barf, gag, etc.<br>    endif<br>endif</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>当然，你也许会说，使用 `override` 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 `override` 是可以达到这样的效果，可是 `override` 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。<br><br><br><br>## -<span class="hljs-number">8</span>- shell函数<br><br>shell函数就是用来执行shell命令的函数。它的参数是操作系统的shell命令，操作系统的标准输出会作为函数的返回值，可以用来给变量赋值，也可以用于函数的嵌套。<br><br></code></pre></td></tr></table></figure><p>contents :&#x3D; $(shell cat foo)<br>files :&#x3D; $(shell echo *.c)</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>除了<span class="hljs-built_in">shell</span>函数之外，直接在<span class="hljs-built_in">shell</span>命令前后加上反引号`，这样同样也能执行<span class="hljs-built_in">shell</span>命令。<br><br></code></pre></td></tr></table></figure><p>contents :&#x3D; <code>cat foo</code><br>files :&#x3D; <code>echo *.c</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>注意，这个函数会新生成一个<span class="hljs-built_in">Shell</span>程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐式规则可能会让你的<span class="hljs-built_in">shell</span>函数执行的次数比你想像的多得多。<br><br><br><br><span class="hljs-meta">## -9- 控制make函数</span><br><br><span class="hljs-built_in">make</span>提供了一些函数来控制<span class="hljs-built_in">make</span>的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让<span class="hljs-built_in">make</span>继续执行，还是停止。<br><br></code></pre></td></tr></table></figure><p>$(error &lt;text …&gt;)</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>产生一个致命的错误， `&lt;<span class="hljs-built_in">text</span> ...&gt;` 是错误信息。注意，<span class="hljs-keyword">error</span>函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：<br><br>示例一：<br><br></code></pre></td></tr></table></figure><p>ifdef ERROR_001<br>    $(error error is $(ERROR_001))<br>endif</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>示例二：<br><br></code></pre></td></tr></table></figure><p>ERR &#x3D; $(error found an error!)</p><p>.PHONY: err</p><p>err: $(ERR)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br>示例一会在变量ERROR_001定义了后执行时产生<span class="hljs-keyword">error</span>调用，而示例二则在目录<span class="hljs-keyword">err</span>被执行时才发生<span class="hljs-keyword">error</span>调用。<br><br></code></pre></td></tr></table></figure><p>$(warning &lt;text …&gt;)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。<br><br><br><br><span class="hljs-section"># 0x08 Make的运行</span><br><br>这一部分主要是make这个命令是如何使用的，以及make有关参数的讲解。<br><br><br><br><span class="hljs-section">## -1- make的退出码</span><br><br>make命令执行后有三个退出码：<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**0**</span><br><br>  表示成功执行。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**1**</span><br><br>  如果make运行时出现任何错误，其返回1。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**2**</span><br><br>  如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。<br><br><br><br><span class="hljs-section">## -2- 指定Makefile</span><br><br>GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。<br><br>如果希望make执行我们指定的makefile，那么可以使用make的 <span class="hljs-code">`-f`</span> 或是 <span class="hljs-code">`--file`</span> 参数（ <span class="hljs-code">`--makefile`</span> 参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：<br><br></code></pre></td></tr></table></figure><p>make –f hchen.mk</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>如果在<span class="hljs-built_in">make</span>的命令行不只一次地使用了 <span class="hljs-string">`-f`</span> 参数，那么，所有指定的makefile将会被连在一起传递给<span class="hljs-built_in">make</span>执行。<br><br><br><br>## <span class="hljs-number">-3</span>- 指定目标<br><br>一般来说，<span class="hljs-built_in">make</span>的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是<span class="hljs-built_in">make</span>的默认行为。如果希望<span class="hljs-built_in">make</span>以我们指定的目标为最终目标的话，就可以显式的指出你希望完成的目标，类似于<span class="hljs-string">`make clean`</span>。<br><br>任何在makefile中的目标都可以被指定成终极目标，但是除了以 <span class="hljs-string">`-`</span> 打头，或是包含了 <span class="hljs-string">`=`</span> 的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为<span class="hljs-built_in">make</span>的终极目标，也就是说，只要<span class="hljs-built_in">make</span>可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。<br><br><br><br>有一个<span class="hljs-built_in">make</span>的环境变量叫 <span class="hljs-string">`MAKECMDGOALS`</span> ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：<br><br></code></pre></td></tr></table></figure><p>sources &#x3D; foo.c bar.c<br>ifneq ( $(MAKECMDGOALS),clean)<br>    include $(sources:.c&#x3D;.d)<br>endif</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>基于上面的这个例子，只要我们输入的命令不是“make <span class="hljs-built_in">clean</span>”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。<br><br>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：<br><br></code></pre></td></tr></table></figure><p>.PHONY: all<br>all: prog1 prog2 prog3 prog4</p><pre><code class="hljs">从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”，“prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用 “make prog2”来单独编译目标“prog2”。即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。- all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。- clean:这个伪目标功能是删除所有被make创建的文件。- install:这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。- print:这个伪目标的功能是例出改变过的源文件。- tar:这个伪目标功能是把源程序打包备份。也就是一个tar文件。- dist:这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。- TAGS:这个伪目标功能是更新所有的目标，以备完整地重编译使用。- check和test:这两个伪目标一般用来测试makefile的流程。## -2- 检查规则有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：- `-n`, `--just-print`, `--dry-run`, `--recon`  不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。- `-t`, `--touch`  这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。- `-q`, `--question`  这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。- `-W &lt;file&gt;`, `--what-if=&lt;file&gt;`, `--assume-new=&lt;file&gt;`, `--new-file=&lt;file&gt;`  这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。另外一个很有意思的用法是结合 `-p` 和 `-v` 来输出makefile被执行时的信息（这个将在后面讲述）。## -3- make参数下面列举了所有GNU make 3.80版的参数定义。不过还是推荐去查看make的手册，这样可以得到最准确的解释。- `-b`, `-m`  这两个参数的作用是忽略和其它版本make的兼容性。- `-B`, `--always-make`  认为所有的目标都需要更新（重编译）。- `-C` *&lt;dir&gt;*, `--directory`=*&lt;dir&gt;*  指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”。- `-debug`[=*&lt;options&gt;*]  输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：a: 也就是all，输出所有的调试信息。（会非常的多）b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i: 也就是implicit，输出所有的隐含规则。j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。- `-d`  相当于“–debug=a”。- `-e`, `--environment-overrides`  指明环境变量的值覆盖makefile中定义的变量的值。- `-f`=*&lt;file&gt;*, `--file`=*&lt;file&gt;*, `--makefile`=*&lt;file&gt;*  指定需要执行的makefile。- `-h`, `--help`  显示帮助信息。- `-i` , `--ignore-errors`  在执行时忽略所有的错误。- `-I` *&lt;dir&gt;*, `--include-dir`=*&lt;dir&gt;*  指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。- `-j` [*&lt;jobsnum&gt;*], `--jobs`[=*&lt;jobsnum&gt;*]  指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）- `-k`, `--keep-going`  出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。- `-l` *&lt;load&gt;*, `--load-average`[=*&lt;load&gt;*], `-max-load`[=*&lt;load&gt;*]  指定make运行命令的负载。- `-n`, `--just-print`, `--dry-run`, `--recon`  仅输出执行过程中的命令序列，但并不执行。- `-o` *&lt;file&gt;*, `--old-file`=*&lt;file&gt;*, `--assume-old`=*&lt;file&gt;*  不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。- `-p`, `--print-data-base`  输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 “make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的 makefile会是很有用的，特别是当你的环境变量很复杂的时候。- `-q`, `--question`  不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。- `-r`, `--no-builtin-rules`  禁止make使用任何隐含规则。- `-R`, `--no-builtin-variabes`  禁止make使用任何作用于变量上的隐含规则。- `-s`, `--silent`, `--quiet`  在命令运行时不输出命令的输出。- `-S`, `--no-keep-going`, `--stop`  取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。- `-t`, `--touch`  相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。- `-v`, `--version`  输出make程序的版本、版权等关于make的信息。- `-w`, `--print-directory`  输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。- `--no-print-directory`  禁止“-w”选项。- `-W` *&lt;file&gt;*, `--what-if`=*&lt;file&gt;*, `--new-file`=*&lt;file&gt;*, `--assume-file`=*&lt;file&gt;*  假定目标&lt;file&gt;;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;;的修改时间为当前时间。- `--warn-undefined-variables`  只要make发现有未定义的变量，那么就输出警告信息。# 附录## 库文件相关问答以下回答来自ChatGPT 3.5**Q：为什么目标要写成archive.a(member.o)这样**&gt;A：在GNU Make中，`archive.a(member.o)` 表示静态库（archive）中的一个成员（member），这种表示方式通常用于静态库的构建和维护。这里的 `archive.a` 是一个静态库文件，`member.o` 是该静态库中的一个对象文件。&gt;&gt;这种语法的用途主要是对静态库进行精确的成员管理。你可以使用这种形式来指定只从静态库中提取或添加特定的对象文件，而不是整个静态库。&gt;&gt;例如，在构建时，你可能只想要将某个对象文件加入静态库，而不是整个重新构建静态库。类似地，在一些规则中，你可能只关心特定的库成员。&gt;&gt;语法为 `archive.a(member.o)` 提供了精细的控制，使你能够指定与静态库关联的特定文件。这对于大型项目，特别是库的管理，非常有用。**Q：帮我解释一下库文件**&gt; A：库文件（Library）是一种包含可重用代码的二进制文件集合。这些文件包含已经编译好的对象代码，可以由程序员在其项目中引用，以便重用这些代码而不必重新编写。库文件的目的是提供一种模块化的方式来组织和共享代码。&gt;&gt; 有两种主要类型的库文件：&gt;&gt; 1. **静态库（Static Library）：** 静态库是一组已编译的目标文件的集合，这些目标文件在链接时会被直接合并到最终的可执行文件中。它的文件扩展名通常是 `.a`（在Unix/Linux系统）或 `.lib`（在Windows系统）。&gt;&gt;    静态库的优点是在链接时会将库中的代码嵌入到可执行文件中，使得最终的可执行文件独立于库文件。缺点是如果多个程序使用相同的静态库，它们都会有一份该库的拷贝，可能导致可执行文件较大。&gt;&gt; 2. **动态库（Dynamic Library）：** 动态库是一组已编译的目标文件的集合，它在运行时被加载到内存中，并可以被多个程序共享。它的文件扩展名通常是 `.so`（在Unix/Linux系统）或 `.dll`（在Windows系统）。&gt;&gt;    动态库的优点是多个程序可以共享同一份库，从而减小可执行文件的大小。缺点是程序在运行时需要确保动态库的存在，并且在不同的系统中可能需要处理不同的动态库版本和依赖关系。&gt;&gt; 在编写程序时，程序员可以通过链接器（Linker）将库文件与他们的代码链接起来。库文件中的代码可以包括函数、变量、类等，使得程序员可以使用这些库提供的功能而不必重新实现。库文件对于代码的组织和复用非常重要，它们提供了一种有效的方式来管理和共享代码。**Q：我可否理解成  库文件就是一类目标文件.o的集合**&gt; A：是的，你理解得很正确。库文件可以看作是一组目标文件（`.o` 文件）的集合。这些目标文件都是通过编译源代码而生成的，然后链接在一起形成一个库文件。库文件中的目标文件包含了已编译的代码，如函数、变量等，可以被其他程序或库引用。&gt;&gt; 在静态库的情况下，这些目标文件在链接时会被直接合并到可执行文件中。在动态库的情况下，库文件在运行时被加载到内存中，并且多个程序可以共享同一份动态库。&gt;&gt; 因此，你可以将库文件视为一种组织和打包已编译代码的方式，以便于在不同的项目中进行共享和重用。**Q：在C语言中经常调用的printf函数是否已经编译为了库文件**&gt; A：是的，`printf` 函数通常包含在标准C库（Standard C Library）中，这是一个包含许多常见C语言函数的库。在大多数C编译器中，`printf` 函数的实现是作为库的一部分提供的。&gt;&gt; 对于大多数操作系统和编译器，C语言的标准库通常是由系统提供的。在Unix和Linux系统上，标准C库通常是 `libc`（例如，`glibc` 是GNU C库的实现）。在Windows系统上，标准C库是 Microsoft C Runtime Library（CRT）。&gt;&gt; 当你使用 `printf` 函数时，编译器会知道在标准C库中查找这个函数的实现。在链接过程中，编译器会将标准C库链接到你的程序中，以确保 `printf` 等函数能够正确地被调用。&gt;&gt; 在编写C程序时，你通常不需要显式链接标准C库，因为这通常是默认的。然而，在某些情况下，可能需要确保正确地链接了标准C库，特别是在一些嵌入式系统或裸机编程的场景中。**Q：那库文件的源文件为什么还存在呢**&gt; A：在软件开发中，库文件（静态库或动态库）的源文件通常是为了提供库的源代码，以便进行编译、调试、理解实现细节等目的。源文件通常以扩展名 `.c`（C语言源文件）或 `.cpp`（C++语言源文件）为结尾。&gt;&gt; 以下是为什么库文件的源文件仍然存在的一些原因：&gt;&gt; 1. **调试和分析：** 当开发者遇到问题时，有时需要查看库的源代码以进行调试和分析。源文件的可读性使得开发者能够理解库的实现细节，有助于定位和修复问题。&gt;&gt; 2. **自定义编译：** 有时，开发者可能希望使用不同的编译选项或对库进行一些修改，并重新编译库。在这种情况下，库的源文件是必需的。&gt;&gt; 3. **构建特定版本：** 在某些情况下，开发者可能需要构建特定版本的库，这可能需要访问库的源代码。&gt;&gt; 4. **学习和教育：** 学习和教育是另一个常见的原因。库的源代码可以作为学习编程、学习算法、学习库的实现方式的资源。&gt;&gt; 请注意，库的用户通常只需要库的二进制形式（静态库或动态库）以及相应的头文件（包含库的函数声明等），而不需要库的完整源代码。因此，发布库时，通常只提供二进制形式和头文件。然而，在开发阶段，库的源代码是非常重要的资源。**Q：在linux上，编译器如何根据头文件确定到对应的库文件呢，编译器如何区分是库文件的头文件还是用户自己编写的头文件呢**&gt;A：在Linux上，编译器（例如 GCC）如何找到对应的库文件与头文件有关。以下是一些关键的概念：&gt;&gt;1. **头文件（Header Files）：** 头文件通常具有 `.h` 扩展名，包含了函数声明、结构体定义、常量等。头文件用于在源代码中声明函数或引入库的声明，以便编译器在编译时能够正确理解和验证对这些函数的调用。&gt;&gt;2. **库文件（Library Files）：** 库文件通常包含已编译的二进制代码，例如静态库（`.a`）或动态库（`.so`）。库文件提供了函数的实现，而头文件提供了函数的声明。&gt;&gt;3. **搜索路径：** 编译器使用一组搜索路径来查找头文件和库文件。这些路径包括系统默认路径和用户自定义路径。默认路径可能包括 `/usr/include` 用于头文件，以及 `/usr/lib` 或 `/usr/lib64` 用于库文件。&gt;&gt;    - **头文件搜索路径：** 编译器使用 `-I` 选项指定额外的头文件搜索路径，例如 `-I/path/to/headers`。&gt;    &gt;    - **库文件搜索路径：** 编译器使用 `-L` 选项指定额外的库文件搜索路径，例如 `-L/path/to/libs`。&gt;&gt;4. **库命名约定：** 在Linux中，库文件的命名约定通常是 `lib&lt;name&gt;.a` 或 `lib&lt;name&gt;.so`，其中 `&lt;name&gt;` 是库的名字。例如，`libm.a` 或 `libm.so`。&gt;&gt;5. **链接器选项：** 在链接阶段，使用 `-l` 选项指定要链接的库。例如，`-lm` 表示链接数学库。链接器在搜索库文件时会根据命名约定自动查找合适的库文件。&gt;&gt;    - **静态库：** 使用 `-l&lt;name&gt;` 表示链接静态库。例如，`-lmylib` 表示链接 `libmylib.a`。&gt;    &gt;    - **动态库：** 使用 `-l&lt;name&gt;` 表示链接动态库。例如，`-lmylib` 表示链接 `libmylib.so`。&gt;&gt;在编译器搜索头文件和库文件时，它会按照特定的顺序和规则查找，通常按照用户指定的路径、系统默认路径以及一些标准路径。如果头文件或库文件在搜索路径中找不到，编译器将生成相应的错误信息。&gt;&gt;对于区分库文件的头文件和用户自己编写的头文件，通常没有直接的方式。编译器根据搜索路径和命名约定来查找文件。如果头文件在系统默认路径或用户指定的路径中，并且符合命名约定，编译器就会找到它。因此，要确保头文件和库文件的名字不会与系统标准或其他库冲突。**Q：还是之前那个问题，编译器在预编译完成之后，以stdio.h为例，在编译printf这个函数时，编译器为什么知道该函数已经被编译为库函数了而非是.c的源码呢**&gt;A：当编译器在预处理和编译阶段处理源代码时，它会遇到 `#include &lt;stdio.h&gt;` 这样的预处理指令。这个指令告诉编译器去系统的标准头文件路径中查找 `stdio.h` 文件并将其内容插入到源代码中。&gt;&gt;`stdio.h` 是标准C库头文件，其中包含了 `printf` 函数的声明。在预处理和编译阶段，编译器并不关心这个函数是如何实现的，它只需要知道函数的声明以便在后续阶段进行类型检查。&gt;&gt;在链接阶段，编译器会生成目标文件（`.o` 文件）包含了对 `printf` 函数的引用。然后，在链接器阶段，链接器会将目标文件与库文件链接在一起，以解析对 `printf` 的引用。&gt;&gt;如果是静态库，链接器会从静态库文件中提取 `printf` 函数的实现，并将其嵌入最终的可执行文件中。如果是动态库，链接器会在运行时动态加载动态库，并将 `printf` 函数的地址解析为在库中的实现。&gt;&gt;在这个过程中，编译器并不关心 `printf` 函数的具体实现是来自源代码还是库文件。它只关心函数的声明以及如何将对该函数的引用解析为实际的代码。这就是为什么在编译时，编译器并不需要源代码，而只需要头文件的原因。**Q：还是没懂，再详细解释一下**&gt; A：好的，让我更详细地解释一下整个过程。&gt;&gt; 1. **预处理阶段：**&gt;    - 在预处理阶段，编译器会执行一系列的预处理操作，其中之一是处理 `#include` 指令。当编译器遇到 `#include &lt;stdio.h&gt;` 时，它会查找系统的标准头文件路径，找到 `stdio.h` 文件并将其内容插入源代码中。这是为了让编译器知道标准库中函数的声明，比如 `printf`。&gt;&gt; 2. **编译阶段：**&gt;    - 在编译阶段，编译器会将源代码翻译成汇编代码。这一阶段中，编译器只关注函数的声明，而不需要关心函数的实现。所以，在这个阶段，它并不需要 `printf` 函数的源代码，只需要知道函数的声明，即函数的原型（prototype）。&gt;&gt; 3. **链接阶段：**&gt;    - 在链接阶段，编译器生成目标文件（通常是 `.o` 文件）。这个文件包含了对 `printf` 函数的引用，但并不包含函数的实现。&gt;    - 接下来，链接器将目标文件与库文件链接在一起。对于 `printf` 函数，它来自于标准C库（`libc`）。链接器会从标准C库中提取 `printf` 函数的实现，然后将其嵌入最终的可执行文件中。&gt;    - 如果是静态库，整个 `printf` 函数的实现将被嵌入到可执行文件中。&gt;    - 如果是动态库，链接器会在可执行文件中留下一个引用，告诉操作系统在运行时需要动态加载 `libc.so`，并在内存中解析 `printf` 函数的地址。&gt;&gt; 4. **运行时阶段：**&gt;    - 当你运行可执行文件时，操作系统会负责动态加载库（如果是动态库），并解析函数的地址。&gt;    - 在程序执行过程中，实际的 `printf` 函数代码从库文件加载到内存中，并被调用。&gt;&gt; 总结起来，编译器在编译阶段并不关心函数的具体实现，而是通过头文件获取函数的声明。在链接阶段，实际的函数实现会被链接到可执行文件中，无论是嵌入到可执行文件中（静态库）还是在运行时动态加载（动态库）。**Q：链接器将目标文件与库文件链接在一起。对于 printf 函数，它来自于标准C库（libc）。链接器会从标准C库中提取 printf 函数的实现，然后将其嵌入最终的可执行文件中。 在这个过程中，链接器为什么知道printf来自库文件而非其他的目标文件呢**&gt; A：在链接阶段，链接器并不是根据函数名直接知道一个函数是来自库文件还是其他目标文件。链接器主要通过符号解析（Symbol Resolution）的过程来确定符号（如函数名）的来源。这个过程包括以下几个步骤：&gt;&gt; 1. **符号表（Symbol Table）：** 在目标文件和库文件中都包含有符号表，记录了文件中定义和引用的符号。符号可以是函数、变量或其他标识符。&gt;&gt; 2. **符号解析：** 链接器会遍历目标文件和库文件，查找每个文件中定义和引用的符号，并建立一个符号表的全局视图。&gt;&gt; 3. **符号匹配：** 当链接器遇到一个引用的符号（如 `printf`）时，它会在符号表中查找这个符号的定义。如果找到了，链接器就能确定这个符号是来自某个库文件或目标文件。&gt;&gt; 4. **库的搜索：** 如果链接器在已知的目标文件中找不到符号的定义，它会继续搜索库文件。链接器会按照命令行参数的顺序搜索库，直到找到符号的定义或者遍历完所有的库。&gt;&gt; 在 `printf` 的例子中，链接器首先在目标文件中查找 `printf` 的定义。如果找不到，它会继续搜索链接时指定的库文件，其中通常包括标准C库（`libc`）。&gt;&gt; 关键点在于符号的定义和引用。如果目标文件或库文件中定义了 `printf`，链接器就能找到这个定义。如果没有，链接器就会在库文件中继续搜索。这是为什么在链接时需要指定库文件的原因，以便链接器知道从哪里找到缺失的符号。**Q：也就是说，即使我包含了stdio.h的头文件，但是我在某个.c中实现了printf的函数，那在链接时，printf最终就会指向我所编写的printf函数**&gt; A：是的，你理解得对。在链接阶段，链接器会根据符号解析的过程来确定最终引用的符号的实现。如果你在某个 `.c` 文件中实现了 `printf` 函数，并且在其他文件中引用了 `printf`，链接器会选择使用你自己实现的 `printf` 函数而不是标准C库中的版本。&gt;&gt; 这种情况下，链接器会将你的 `.c` 文件编译生成的目标文件（`.o` 文件）与其他目标文件进行链接，生成最终的可执行文件。在这个过程中，符号解析确保所有引用的符号都能找到对应的定义。&gt;&gt; 这也说明了为什么在C语言中，通常将函数的声明放在头文件中，而将函数的定义放在 `.c` 文件中。头文件用于在编译阶段提供函数的声明，以便在其他文件中引用。然后，在链接阶段，链接器根据符号解析将这些引用与实际的定义连接起来。# -END-</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>make</tag>
      
      <tag>makefiles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习笔记</title>
    <link href="/blog/2023/10/31/study/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2023/10/31/study/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-学习资料"><a href="#0x00-学习资料" class="headerlink" title="0x00 学习资料"></a>0x00 学习资料</h1><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">Learn Regex the Easy Way</a></p><p><a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p><p><a href="https://c.runoob.com/front-end/854/">正则表达式在线测试工具</a></p><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/regex/index.html">轻松学习正则表达式</a></p><h1 id="0x01-什么是正则表达式"><a href="#0x01-什么是正则表达式" class="headerlink" title="0x01 什么是正则表达式"></a>0x01 什么是正则表达式</h1><p>维基上解释如下：</p><blockquote><p><strong>正则表达式</strong>（英语：Regular expression，常简写为regex、regexp），又称<strong>规律表达式</strong>、<strong>正则表示式</strong>、<strong>正则表示法</strong>、<strong>规则表达式</strong>、<strong>常规表示法</strong>，是计算机科学计算机科学)概念，用简单字符串来描述、匹配文中全部匹配指定格式的字符串字符串，现在很多文本编辑器文本编辑器都支持用正则表达式搜索、取代匹配指定格式的字符串。</p></blockquote><p>个人理解：</p><p>正则表示式是一种用来描述字符串匹配模式的语法，使用正则表达式可以从字符串中找到符合匹配模式的结果。这里的匹配模式是指某种自定的规则，该规则描述了你想要的结果在整个字符串中出现的规律。使用正则表达式就类似在windows平台下使用的通配符*、？，但是其功能要强大得多，同时语法也丰富得多。</p><h1 id="0x02-基本匹配"><a href="#0x02-基本匹配" class="headerlink" title="0x02 基本匹配"></a>0x02 基本匹配</h1><p>最基本的匹配就是输入什么就匹配什么， 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><p>正则表达式是大小写敏感的，所以<code>the</code>不会匹配<code>The</code>。</p><blockquote><p>“the” &#x3D;&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><p>PS：书写正则表达式时，通常会将模式的语法写在<code>/pattern/</code>两个斜杠之间，用来标识其使用正则表达式</p><h1 id="0x03-元字符"><a href="#0x03-元字符" class="headerlink" title="0x03 元字符"></a>0x03 元字符</h1><p>在基本匹配中，有些字符无法通过基本匹配的方式直接匹配，这些字符是元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。以下是一些元字符的介绍：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定字符类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;&#x3D;0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;&#x3D;1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 &#96;[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="1-点运算符"><a href="#1-点运算符" class="headerlink" title="-1- 点运算符."></a>-1- 点运算符<code>.</code></h2><p>点运算符表示任意<strong>单个</strong>字符，这里要注意两点，</p><ul><li>点运算符代表至少有一个字符，也就是点运算符至少是占一位的</li><li>点运算符不匹配换换行符<code>\r</code>、<code>\n</code>，要匹配全体字符，要使用<code>(.|\r|\n)</code></li></ul><blockquote><p>“.ar” &#x3D;&gt; The <strong>car</strong> <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h2 id="2-字符类"><a href="#2-字符类" class="headerlink" title="-2- 字符类[]"></a>-2- 字符类<code>[]</code></h2><p>方括号用来指定一个字符类，字符类表示的是该集合中的任意<strong>一个</strong>元素，无论字符类中包含了多少个字符，在匹配时也只占一位。</p><blockquote><p>“[Tt]he” &#x3D;&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p></blockquote><p>在字符类中，大部分元字符是失效的，这些元字符在方括号内只表示它们字符本身，但是<code>-</code>和<code>^</code>和<code>\</code>有其他含义。</p><ul><li><p><code>-</code>表示一个字符范围，指定从其前一位的ASCII值到其后一位的ASCII值的中间的全部字符，常用的有[A-Z]表示全部大写字母，[a-z]表示全部小写字母，[0-9]表示全部数字。</p></li><li><p>如果想要表示<code>-</code>本身，可以将其放在字符类的第一位或者最后一位，如果一定要将其放在字符类的两个字符中间，可以使用转义字符<code>\</code>来表示其本身。</p></li><li><p>表示转义字符<code>\</code>本身在字符类内依然要用<code>\\</code>来表示。</p></li></ul><h2 id="3-否定字符类"><a href="#3-否定字符类" class="headerlink" title="-3- 否定字符类[^]"></a>-3- 否定字符类<code>[^]</code></h2><p>否定字符类就是反选字符类中的元素，也就是字符类中的元素都排除掉，和字符类一样，否定字符类也是只占<strong>一位</strong>的。</p><p>否定字符类也是代表的也是一个集合中的某一个元素，只是该集合是通过在全部字符集中排除掉一部分得到的。</p><p>其他元字符在否定字符类的含义与在元字符内是一样的，如果想表示<code>^</code>字符，并且一定要将其放在字符类的第一位，可以使用转义字符来表示</p><blockquote><p>“[^c]ar” &#x3D;&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h2 id="4-重复次数"><a href="#4-重复次数" class="headerlink" title="-4- 重复次数"></a>-4- 重复次数</h2><p>表示重复次数的元字符有三个，分别是</p><ul><li><p>*号</p><p>匹配在*号之前出现的字符0次及0次以上（大于等于0次），与点运算符连用<code>.*</code>可以匹配所有字符串</p><blockquote><p>“[a-z]<em>“ &#x3D;&gt; T*<em>he</em></em> <strong>car</strong> <strong>parked</strong> <strong>in</strong> <strong>the</strong> <strong>garage</strong> </p></blockquote></li><li><p>+号</p><p>匹配在+号之前出现的字符1次及1次以上（大于等于1）</p><blockquote><p>“c.+t” &#x3D;&gt; The fat <strong>cat sat on the mat</strong>.</p></blockquote></li><li><p>?号</p><p>匹配在?号之前出现的字符可能出现也可能不出现（0次或1次）</p><blockquote><p>“[T]?he” &#x3D;&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p></blockquote></li></ul><p>以上三种符号均可以与字符类以及否定字符类连用</p><h2 id="5-自定义重复次数"><a href="#5-自定义重复次数" class="headerlink" title="-5- 自定义重复次数{}"></a>-5- 自定义重复次数<code>&#123;&#125;</code></h2><p> <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。</p><p>例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。<code>?</code>号等价于<code>&#123;0,1&#125;</code>。</p><p>可以省略第二个参数。 例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。<code>*</code>号等价于<code>&#123;0,&#125;</code>，<code>+</code>号等价于<code>&#123;1,&#125;</code>。</p><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]&#123;3&#125;</code> 匹配3位数字</p><h2 id="6-字符集"><a href="#6-字符集" class="headerlink" title="-6- 字符集()"></a>-6- 字符集<code>()</code></h2><p>字符集是一组写在 <code>()</code> 中的子模式。<code>()</code> 中包含的内容将会被看成一个整体。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>()</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>()</code> 则表示整个标群内的字符重复 N 次。</p><h2 id="7-或运算符"><a href="#7-或运算符" class="headerlink" title="-7- 或运算符|"></a>-7- 或运算符<code>|</code></h2><p>或运算符就是表示或者的意思，表示运算符前后元素二选其一，但是二者必须选其一。或运算符<code>|</code>的优先级最低</p><blockquote><p>“(T|t)he|car” &#x3D;&gt; <strong>The</strong> <strong>car</strong> is parked in <strong>the</strong> garage.</p></blockquote><h2 id="8-转义字符"><a href="#8-转义字符" class="headerlink" title="-8- 转义字符\"></a>-8- 转义字符<code>\</code></h2><p>转义字符与其在C语言中的用法很像，反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。对于特殊字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些，如果想要表达其本身字符的含义则要在其前面加上反斜线 <code>\</code>。</p><p>对于一些控制字符，如回车，空格之类的，也需要使用转义字符加字母来表示；此外，正则表达式还定义了一些字符集的简写，也需要用到转义字符</p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR&#x2F;LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="9-锚点"><a href="#9-锚点" class="headerlink" title="-9- 锚点"></a>-9- 锚点</h2><p>锚点有两个<code>^</code>和<code>$</code>，锚点可以规定匹配位置，<code>^</code>是从头指定开头，<code>$</code>指定结尾</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><blockquote><p>“^(T|t)he” &#x3D;&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><blockquote><p>“(at.)$” &#x3D;&gt; The fat cat. sat. on the m<strong>at.</strong></p></blockquote><h1 id="0x04-零宽断言"><a href="#0x04-零宽断言" class="headerlink" title="0x04 零宽断言"></a>0x04 零宽断言</h1><p>前面的大部分语法都是用来描述用来想要匹配本身是怎么样的，但是有时我们还希望描述被匹配到的字符串的位置，这时就需要用到零宽断言。零宽断言与前面的<code>^</code>，<code>$</code>，<code>\b</code>，<code>\B</code>类似，都是用于描述被匹配模式的位置信息的，可以用来控制想要的字符串前后需要有或者不能有什么。</p><p>之所以叫零宽断言，可能是因为该语法本身不参与匹配，只用于限定想要匹配的字符串的位置，所以其宽度为零。</p><p>零宽断言的支持和正则引擎有关，有些引擎不支持零宽断言。这里的几种断言的英文名其实比中文名更能够表明其含义。</p><ul><li><code>(?=exp)</code>零宽正向先行断言(lookahead)</li><li><code>(?!exp)</code>零宽负向先行断言(negative lookahead)</li><li><code>(?&lt;=exp)</code>零宽正回顾后发断言(lookbehind)</li><li><code>(?&lt;!exp)</code>零宽负回顾后发断言(negative lookbehind)</li></ul><h2 id="1-零宽正向先行断言-lookahead"><a href="#1-零宽正向先行断言-lookahead" class="headerlink" title="-1- 零宽正向先行断言(lookahead)"></a>-1- 零宽正向先行断言(lookahead)</h2><p><code>(?=exp)</code>，它断言自身出现的位置的后面能匹配表达式exp</p><p>例如，<code>\b\w+(?=ing\b)</code>，就会匹配以ing结尾的单词<strong>前面部分</strong>，需要注意，零宽断言自己断言本身是不参与匹配的</p><blockquote><p>“\b\w+(?&#x3D;ing\b)” &#x3D;&gt; I’m <strong>sing</strong>ing while you’re <strong>danc</strong>ing</p></blockquote><h2 id="2-零宽正回顾后发断言-lookbehind"><a href="#2-零宽正回顾后发断言-lookbehind" class="headerlink" title="-2- 零宽正回顾后发断言(lookbehind)"></a>-2- 零宽正回顾后发断言(lookbehind)</h2><p><code>(?&lt;=exp)</code>，它断言自身出现的位置的前面能匹配表达式 exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。</p><blockquote><p>“(?&lt;&#x3D;\bre)\w+\b” &#x3D;&gt; re<strong>ading</strong> a book</p></blockquote><h2 id="3-零宽负向先行断言-negative-lookahead"><a href="#3-零宽负向先行断言-negative-lookahead" class="headerlink" title="-3- 零宽负向先行断言(negative lookahead)"></a>-3- 零宽负向先行断言(negative lookahead)</h2><p><code>(?!exp)</code>，与零宽正向先行断言相反，它断言的是此位置的后面不能匹配表达式 exp。</p><p>例如：<code>\d&#123;3&#125;(?!\d)</code>匹配三位数字，而且这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串 abc 的单词。</p><h2 id="4-零宽负回顾后发断言-negative-lookbehind"><a href="#4-零宽负回顾后发断言-negative-lookbehind" class="headerlink" title="-4- 零宽负回顾后发断言(negative lookbehind)"></a>-4- 零宽负回顾后发断言(negative lookbehind)</h2><p><code>(?&lt;!exp)</code>，同理，零宽负回顾后发断言也就指断言位置的前面不能出现表达式exp</p><p>例如：<code>(?&lt;![a-z])\d&#123;7&#125;</code>匹配前面不是小写字母的七位数字。</p><h1 id="0x05-修饰符（标记）"><a href="#0x05-修饰符（标记）" class="headerlink" title="0x05 修饰符（标记）"></a>0x05 修饰符（标记）</h1><p>标记不写在正则表达式里，标记位于表达式之外，格式为<code>/pattern/flags</code></p><h2 id="1-修饰符g"><a href="#1-修饰符g" class="headerlink" title="-1- 修饰符g"></a>-1- 修饰符<code>g</code></h2><p>global - 全局匹配，g 修饰符可以查找字符串中所有的匹配项。默认情况下（不带g），正则匹配会在找到第一个结果时停止，如果加上修饰符g，则会查找整个字符串，找到所有的匹配项。</p><h2 id="2-修饰符i"><a href="#2-修饰符i" class="headerlink" title="-2- 修饰符i"></a>-2- 修饰符<code>i</code></h2><p>ignore - 不区分大小写，i修饰符指定匹配时不区分大小写</p><h2 id="3-修饰符m"><a href="#3-修饰符m" class="headerlink" title="-3- 修饰符m"></a>-3- 修饰符<code>m</code></h2><p>multi line - 多行匹配，修改锚点元字符<code>^</code>和<code>$</code>的含义，使其锚定为每行的开头和结尾。</p><blockquote><p>“&#x2F;.at(.)?$&#x2F;“ &#x3D;&gt; The fat<br>                        cat sat<br>                        on the <strong>mat.</strong></p></blockquote><blockquote><p>“&#x2F;.at(.)?$&#x2F;gm” &#x3D;&gt; The <strong>fat</strong><br>                              cat <strong>sat</strong><br>                              on the <strong>mat.</strong></p></blockquote><h2 id="4-修饰符s"><a href="#4-修饰符s" class="headerlink" title="-4- 修饰符s"></a>-4- 修饰符<code>s</code></h2><p>Singleline - 单行匹配，修改<code>.</code>元字符的含义，使其可以匹配所有的字符（包括<code>\n</code>换行符），在这种模式下，一篇文章可以被看作一行字符串，换行符<code>\n</code>也只是该行中的一个字符罢了。</p><blockquote><p>需要注意的是，单行模式与多行匹配是可以同时使用的，它们二者并不冲突，因为它们针对的元字符都是不同的，同时使用这两个修饰符，就只是同时修改了<code>^</code> <code>$</code> <code>.</code>的含义。</p></blockquote><h1 id="0x06-贪婪和懒惰"><a href="#0x06-贪婪和懒惰" class="headerlink" title="0x06 贪婪和懒惰"></a>0x06 贪婪和懒惰</h1><p>通常情况下，正则匹配时会选择匹配尽可能多的字符，这中匹配策略被称为贪婪匹配。如果我们希望匹配时匹配最少的字符，就需要用<code>?</code>将匹配策略换为懒惰匹配，<code>?</code>添加在重复次数元字符的后面。</p><p>来看一个例子：aabbcb，使用<code>a.*b</code>匹配时，会匹配所有的字符，也就是aabbcb，但是如果使用懒惰匹配<code>a.*?b</code>，则会匹配aab（字符1-3）和ab（字符2-3）。</p><p>这里要注意的是，为什么懒惰匹配的结果不只是ab（字符2-3）呢，这时因为正则匹配中有一条规律的优先级比贪婪和懒惰要高：最先开始的匹配拥有最高的优先权，由于第一个a最先匹配，所以其拥有最高的优先级，因此可以不受贪婪和懒惰策略的影响。</p><table><thead><tr><th>懒惰限定符</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但是尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但是尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但是尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但是尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次或更多次，但是尽可能少重复</td></tr></tbody></table><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>regex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录配置Typora+PicGo+GitHub图床写博客工具</title>
    <link href="/blog/2023/10/21/study/%E8%AE%B0%E5%BD%95%E9%85%8D%E7%BD%AETypora+PicGo+GitHub%E5%9B%BE%E5%BA%8A%E5%86%99%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"/>
    <url>/blog/2023/10/21/study/%E8%AE%B0%E5%BD%95%E9%85%8D%E7%BD%AETypora+PicGo+GitHub%E5%9B%BE%E5%BA%8A%E5%86%99%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>在之前已经搭建好了博客的框架，现在就差博文了。正所谓磨刀不误砍柴工，在写博客之前，准备一个趁手的工具很重要。对于写博客来说，主要就是解决两个问题，第一个是用哪个markdown编辑器，二就是图片的保存方案。下面就聊聊为什么选择Typora+PicGo+GitHub这套组合来进行博客写作，以及记录我的配置过程。</p><h1 id="0x01-方案选择"><a href="#0x01-方案选择" class="headerlink" title="0x01 方案选择"></a>0x01 方案选择</h1><h2 id="1-markdown编辑器"><a href="#1-markdown编辑器" class="headerlink" title="-1- markdown编辑器"></a>-1- markdown编辑器</h2><p>首先说markdown编辑器，我第一次接触到markdown是无意中在网上冲浪时认识到了notion这款笔记软件，当时我还只接触过doc这种富文本格式的文本以及txt无格式的纯文本，第一次接触markdown这种轻量级的标记语言仿佛是打开了新世界的大门，它太好用了，既不像doc那样臃肿，又不像txt那样完全没有格式，它的语法突出一个恰到好处，够用！notion固然是个很好用的软件，但是用他来写博客还是有些问题，首先是因为它不仅仅只是markdown编辑器，它还支持很多的其他功能，像日历、看板这些，而这些功能在其他的markdown编辑器中就不支持了，降低了它的可移植性；其次是对于图片的保存，notion之类的软件通常都是将图片上传到自身的图床平台，而这些为自身软件搭建的图床当然都是不支持外链访问的，因此导出为markdown就必须将图片打包，否则图片就全挂了，这个后面再细说；最后一点就是notion并没有Linux版本，只能使用网页版，网页版不是不能用，但是确实不好用，这也是我后来放弃用飞书的原因。除了notion之外，一些国产的类notion软件我也都体验过，包括wolai,flowus ,飞书，这类软件都有notion的问题，因为说到底，这些软件都并非是专门的markdown编辑器，而是团队知识文档合作平台，只是支持了markdown文本格式，他们并非为了markdown而服务，并非这些软件做的不好，相反，他们都有各自的长处，但是写博客还是需要寻找其他的写作工具。</p><blockquote><p>使用Notion也能搭建个人博客，如果你感兴趣，可以去自行搜索了解</p></blockquote><p>市面上的markdown编辑器有很多，随便一搜就有一大把，但是他们大致分为两类，一类是源代码写作类型的，其中为代表的就是VScode（VScode原生是不支持预览md的，需要插件支持），包括CSDN的网页版的markdown编辑器也是这种类型。这一类优势是啥呢？可能是方便学习markdown语法？Maybe……反正我用Typora。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310251506592.png"></p><p>另一类是即使渲染类型的，其中最具代表的就是Typora。它最大的优点就是所见即所得，你输入的语法马上就会被渲染成对应的样式。当然，它的缺点就是现在Typora已经是收费软件了。当然，你依以在互联网上找到它过去的不收费版本，这里也提供一个免费版的下载链接：<a href="https://babudiu.com/archives/typora">Typora 最后的免费版 全平台(win mac linux)下载</a></p><p><strong>Typora的正版收费还是比较合理的，目前是<code>89元</code>人民币，如果有经济实力还是建议大家支持正版。</strong></p><p>除了Typora，还有一个开源软件<a href="https://github.com/marktext/marktext">MarkText</a>，同样支持实施渲染markdown，有兴趣可以尝试一下。<del>不过我觉得Typora更好用</del></p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310251509098.png"></p><p>以上的两类编辑器我都用过，萝卜青菜，各有所爱，我最终的选择还是Typora。</p><h2 id="2-图片保存方案"><a href="#2-图片保存方案" class="headerlink" title="-2- 图片保存方案"></a>-2- 图片保存方案</h2><p>如今写博客肯定离不开图片，那图片的保存就成了一个问题。这个问题无非就两个解决方法，一是存在本地，而是存在云端。</p><ul><li><p>存在本地隐私性好，不用用担心安全性问题，稳定，但是用在博客上会影响网页的加载速度，并且联合markdown使用会降低md文件的可移植性，图片必须跟着md文件一起打包，这就会使md文件变得臃肿。</p></li><li><p>用于存放图片的服务器就被称为图床，图片存在图床上可移植性好，无论是放在网页上还是在不同的机器上图都不会挂，但是放在图床就意味着图片不在自己手上，这就意味着导致隐私差，安全性不好，只适合用于存放一些非关键图片。此外，图片加载还会受到网络环境的影响。</p></li></ul><p>权衡利弊，我还是选择使用图床方案，主要是想探索一下图床的使用，其次也能保证md文件良好我移植性，方便搬移到不同的平台上。</p><h2 id="3-图床的选择"><a href="#3-图床的选择" class="headerlink" title="-3- 图床的选择"></a>-3- 图床的选择</h2><p>图床的选择有很多，网上有很多对比的文章，我就不对比了，这里就讲一下我选择github作为图床的原因：</p><ul><li><p>免费，这是最主要的原因，因为我没钱</p></li><li><p>图片不易丢失，github至少在可遇见的未来应该还是不会倒闭的，对比那些小图床服务商，github应该是不会突然跑路的</p></li><li><p>gitee太烂了，我起初是想将图片放在gitee上的，因为毕竟gitee服务器在国内，加载速度还是快太多了，但是gitee对于免费用户的限制太多了，最重要的是现在gitee会封外链访问了，已经无法作为图床使用了，除非你的博客只基于gitee的pages功能搭建。</p><p>放一个知乎的问答：<a href="https://www.zhihu.com/question/524089317">如何看待使用gitee大量屏蔽外链，之后不能在继续做图床了，对大家的影响大吗，这种情况会持续多久？</a></p></li></ul><p>综上，我选择github作为博客的图床。</p><blockquote><p>如果有实力的话，还是建议选择云服务商的OSS存储服务，一般来说存储费都不高，费用高的是流量费，如果网站的浏览量不大的话，整体的费用还是可接受的，但是就是怕被人恶意刷量，还得折腾防小人。</p></blockquote><h2 id="4-PicGo"><a href="#4-PicGo" class="headerlink" title="-4- PicGo"></a>-4- PicGo</h2><p>OK，现在已经选好了图床和编辑器，还差一个工具将编辑器和图床联系起来，这个工具就是PicGo。PicGo可以被Typora调用，当你粘贴图片时，Typora会自动调用PicGo将图片上传，并且自动返回url。为什么选择PicGo呢？那是因为Typora官方支持的工具就是它，当然，PicGo也是足够好用的，并且它是开源的，在Win、Linux、MacOS都可以使用，支持的图床也足够丰富，还有插件可以扩展的它功能，所以大家几乎都使用它。</p><p><a href="https://github.com/Molunerfinn/PicGo">PicGo GitHub页面</a></p><p><a href="https://picgo.github.io/PicGo-Doc/">PicGo 使用指南</a></p><h1 id="0x02-配置过程"><a href="#0x02-配置过程" class="headerlink" title="0x02 配置过程"></a>0x02 配置过程</h1><p>以下过程全程以Ubuntu 22.04为例,其他系统大同小异。</p><h2 id="1-安装Typora"><a href="#1-安装Typora" class="headerlink" title="-1- 安装Typora"></a>-1- 安装Typora</h2><p>首先，需要获取安装包，在linux环境下是deb格式的，使用如下命令对安装进行解包安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dpkg -i Typora_Linux_xxxx_amd64.deb <br></code></pre></td></tr></table></figure><p>输入密码，就安装完成了</p><h2 id="2-准备GitHub仓库"><a href="#2-准备GitHub仓库" class="headerlink" title="-2- 准备GitHub仓库"></a>-2- 准备GitHub仓库</h2><p>打开GitHub新建一个仓库，这个仓库和之前部署博客的仓库一样，必须选择公共仓库。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230150149.png"></p><p>ok，创建仓库完成后，图床就准备好了。It‘s too simple。</p><h3 id="创建token"><a href="#创建token" class="headerlink" title="创建token"></a>创建token</h3><p>我们这里再顺手创建一个token，这个token就相当于github仓库的密码，可以用于访问你的仓库，之后配置picgo时会用到。</p><p>首先来到github的setting页面，选择导航栏最下方的Developer setting（开发者设置）</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025202653090.png"></p><p>然后选择Persional access tokens -&gt; Tokens(classic)</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025202845916.png"></p><p>再然后选择上方的Generate new tokens -&gt; Generate new tokens(classic)</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025203039991.png"></p><p>输入你的账户密码后会来到如下界面，这里的Note是用来给你的token取名字的，分别区分管理，Expiration是有效时间，时间越久风险越高，自行决定，不建议选择无限期。下面的权限只勾选上repo就行了，然后滑动到最底部，选择Generate token。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025203300229.png"></p><p>此时你就获得了一个token，它仅会以明文的形式展示这一次，当你关闭此页面你就再也没办法知道它是什么了，所以这里将它复制保存下来，之后配置PicGo时会用到。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025203722658.png"></p><h2 id="3-安装PicGo"><a href="#3-安装PicGo" class="headerlink" title="-3- 安装PicGo"></a>-3- 安装PicGo</h2><p>打开<a href="https://github.com/Molunerfinn/PicGo">PicGo GitHub页面</a>，找到它的release</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025192018530.png"></p><p>第一次来到这个界面我蒙了，因为我不知道下载哪一个，通常来说，linux的软件安装包是deb格式的拓展名，或者直接是打包好的二进制可执行程序，又或者是纯源码通过编译来安装。但是这里我找不到下载哪一个，通过一番搜索，发现这里有两个是linux下的安装包，一个扩展名为snap，这种安装包是基于snap这种新的包管理方式。对于这种包管理方式我也没接触过，浅浅地了解了一下，其优势是安全以及依赖自包含，其文件内包含了全部依赖的库。AppImage也是一种性质类似的安装包，其本质是一个压缩文件，其内也包含了全部的所需的运行库，因此安装这两个安装包不需要安装其他依赖。这里我下载AppImage，因为安装.snap安装包需要使用snap包管理工具，我当时不会。<br><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025192612648.png"></p><p>下载完成后，赋予安装包可执行权限，使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x PicGo-2.3.1.AppImage<br></code></pre></td></tr></table></figure><p>或者右键 -&gt; 属性 -&gt; 权限 -&gt; 勾选运行执行权限</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025194941228.png"></p><p>然后在终端直接<code>./PicGo-2.3.1.AppImage</code> 执行该安装包，发现会报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlopen(): error loading libfuse.so.2<br><br>AppImages require FUSE to run. <br>You might still be able to extract the contents of this AppImage <br>if you run it with the --appimage-extract option. <br>See https://github.com/AppImage/AppImageKit/wiki/FUSE <br>for more information<br></code></pre></td></tr></table></figure><p>意思是我们执行该安装包缺少FUSE，但是我们可以使用<code>--appimage-extract</code>这个选项来提取该安装包。于是我们的命令就变成了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./PicGo-2.3.1.AppImage --appimage-extract<br></code></pre></td></tr></table></figure><p>回车之后，安装包的文件就被提取出来了，生成了一个名为<code>squashfs-root</code>的文件夹，这个文件夹里就有我们要的picgo可执行文件了,在该目录下执行<code>./picgo</code>可以测试是否能打开PicGo，打开之后会在桌面生成一个小图标，看到这个图标就说明安装PicGo完成了。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025200122451.png"></p><blockquote><p>PicGo有两个版本，一个是带图像界面的，可以通过UI交互的，也就是当前下载的这个。还有一个仅保留核心功能，通过命令行交互的PicGo-Core，PicGo其实也是对PicGo-Core的封装，但是增加了图像界面，更易用，而PicGo-Core使用起来更无感，但是使用门槛更高。大家可以根据使用习惯自行选择。</p><p><a href="https://github.com/PicGo/PicGo-Core">PicGo-Core GitHub界面</a></p></blockquote><h2 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="-4- 配置PicGo"></a>-4- 配置PicGo</h2><p>打开PicGo的主界面，先选择图床设置，再选择GitHub，然后编辑配置，就来到了图床配置界面。下面分别来讲解各项</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231025201525131.png"></p><ul><li><p>图床配置名：该配置的名称，随便取就行</p></li><li><p>设定仓库名：格式为<code>GitHub用户名/图床仓库名</code>，按照创建创建仓库时取得名字来就行</p></li><li><p>设定分支名：上传到仓库的哪个分支上，没修改的话默认是main</p></li><li><p>设定token：相当于密码，使用之前创建GitHub仓库时顺便创建的token</p></li><li><p>设定存储路径：想要图片存放在哪个文件夹下，不填默认是根目录，注前面不能有斜杠&#x2F;，最后的斜杠&#x2F;不能省略</p></li><li><p>设定自定义域名：此项不填，则你上传图片后获取的url是<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/设定存储路径/文件名</code>，填写此项会替换掉前面的<code>https://raw.githubusercontent.com/用户名/仓库名/分支名</code>部分。</p><p>通过这个功能，我们可以使用CDN加速，便于我们在国内访问GitHub图床。这里推荐jsDriver这个免费的CDN，因此这里的格式为<code>https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名</code></p></li></ul><p>配置好之后可以在上传区随便上传一张图片试试能否上传成功，能够成功上传就说明配置成功了。</p><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>CDN（<strong>C</strong>ontent <strong>D</strong>istribution <strong>N</strong>etwork），中文全称是内容分发网络，它的本质是部署多个服务器，用户请求资源时通过最近的服务器来分发资源，降低主服务器的压力，同时也能提升用户的体验。最开始我是没有配置CDN的，因为我都是开着魔法上网的，没有意识到国内网络访问github慢这个问题，直到我想看看博客的手机端的观看体验才发现图片根本加载不出来，这才意识到想要正常在国内访问github图床，就必须配置CDN。</p><p>好在有免费的CDN服务可以白嫖，jsDeliver是一款开源的免费公共CDN，它可以为国内用户加速github的开源项目，所以也可以用来帮助我们加速我们的开源github图床。</p><p>但是jsDeliver目前在国内的备案以及被撤销了，这个CDN的前途目前还不明，这也是这套方案中最薄弱的一环，目前还能正常使用，但是未来的监管如何，现在就无从知晓了。</p><blockquote><p>对于jsDeliver的过往可以看看这篇博文：<a href="https://luotianyi.vc/6295.html">jsDelivr域名遭到DNS污染</a></p></blockquote><blockquote><p> jsDelivr有很多的CDN赞助商共同支持，每一个服务商都会有自己的专有子域名，通过替换访问资源到其他的二级域名可以恢复访问。但这些CDN普遍速度一般，而且前途并不明朗，建议仅供临时使用。</p><blockquote><p>CloudFlare：<code>test1.jsdelivr.net</code><br>CloudFlare：<code>testingcf.jsdelivr.net</code><br>Fastly：<code>fastly.jsdelivr.net</code><br>GCORE：<code>gcore.jsdelivr.net</code></p></blockquote></blockquote><h2 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="-5- 配置Typora"></a>-5- 配置Typora</h2><p>图床以及上传工具已经准备好了，下一步就是将PicGo配置到Typora中了。打开Typora，选择文件 -&gt; 偏好设置 -&gt; 图像，来到如下界面</p><ul><li><p><strong>插入图片时…</strong> ：选择上传图片，并且勾选前两项，最后一项插入时自动转译图片url也可以选上，它的含义是插入时将中文的文件名转译为纯西文文件名，这样可以兼容其他的markdown编辑器，也可以获得更好的移植性，但是会丧失图片名称的可读性，可以自行选择是否勾选。</p></li><li><p><strong>上传服务设定</strong> ：其中上传服务选择PicGo(app)，下面的PicGo路径不要点击后面的文件夹图标去选择，会识别不到picgo的可执行文件。这里找到你的PicGo的安装位置，将路径复制进去，然后在后面加上picgo这个可执行文件的文件名。</p></li></ul><p>点击旁边的验证图片上传选项，会自动用一张typora的图标测试你的配置是否成功，如果此时上传成功了，那么整个配置过程就结束了。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310261005743.png"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>虽然整个配置过程还是相对比较简单，网上也有大把的教程，但是过程中还是遇到了不少困难的，最开始就是不知道如何安装PicGo的Linux版本，确实从来没接触过snap和AppImage这两种安装方式；其次就是在Typora中指定PicGo路径时，在文件浏览器里死活找不到picgo的可执行文件，一度让我想要放弃使用PicGo，改用PicGo-Core，好在最后还是想到了直接手动输入对应路径。总的来说我还是太菜了，害得练啊。</p><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>PicGo</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录利用GitHub+Hexo搭建博客</title>
    <link href="/blog/2023/10/15/study/%E8%AE%B0%E5%BD%95%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/blog/2023/10/15/study/%E8%AE%B0%E5%BD%95%E5%88%A9%E7%94%A8GitHub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>之前在Internet冲浪时经常会搜到一些别人写的博客，通常国内普通人写博客往往是在平台之上创作，通过某乎、某某DN这样的平台。但是有时也能搜到一些个人博客，这些博客往往网页清爽，纯净无广告，有些博客还有些不错特效，抛开文章内容不谈，仅仅是如此清爽的页面就给了人良好的阅读体验。所以我便也想着整一个，这样就可以把自己写的一些垃圾扔在上面了，咱说整就整。</p><p>搭建一个博客的方法有很多，但是对于我这种纯小白来说，使用现成的方案显然是最方便滴。</p><p>首先，搭建博客需要肯定需要一个服务器，当然最好的办法就是自己物理上组一台主机当服务器，然后再搞到一个公网IP，这样整个服务器都完全掌握在自己手里。但是这样的服务器需要大把的“米”，而且在2023年的今天，获取一个私人的公网的IPv4地址也是十分困难滴，因此PlanA PASS。</p><p>随着云服务的发展，现如今通过租的方式来获取一个云服务器也是很容易的。但是云服务终究还是收费的，虽然各家云服务商都有新人优惠，但是小钱也是钱啊，咱这种玩玩而已的blog那自然是能省就省，等以后有钱有闲了再来研究研究这个方案。PlanB暂时放弃。</p><p>那最后咱们选择的方案是啥呢？嘿嘿，就是利用GitHub提供的免费pages功能来搭建这个blog。GitHub给每个人的每个仓库都提供了这个page功能，我认为GitHub的原意应该是方便用户给每个项目搭建一个介绍页面，但是我们正好就可以利用这个功能来搭建一个人博客。</p><p>OK，下面就记录一下我搭建这个blog的过程以及踩过的坑。</p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><h2 id="0-安装git"><a href="#0-安装git" class="headerlink" title="-0- 安装git"></a>-0- 安装git</h2><p>这个太基础了，在windows平台下就去Internet下载对应的安装包，一直默认next就好。</p><p>如果是在Ubuntu平台下，就用如下命令安装吧</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="-1- 创建仓库"></a>-1- 创建仓库</h2><p>创建仓库没什么好说的（<del>如果不会就STFW吧</del>），但唯一要注意的是必须要创建公共仓库</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230150149.png"></p><blockquote><p> 其实如果不会魔法上网，无法使用Github，也可以使用国内的代码托管平台gitee，gitee同样提供pages的功能，但是必须先通过实名认证。但是我还是推荐先学会魔法</p></blockquote><h2 id="2-安装Node-js环境"><a href="#2-安装Node-js环境" class="headerlink" title="-2- 安装Node.js环境"></a>-2- 安装Node.js环境</h2><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230213736.png"></p><p>在<a href="https://nodejs.org/zh-cn">官网</a>上下载一下安装包，LTS是长期维护版，理论上更稳定；Current就是当前最新版。我这里就下载LTS版本了，因为我也用不上新特性。</p><p>我使用的是Ubuntu 22.04，下载下来是一个tar.xz格式的压缩包，使用如下目录进行解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -Jxf node-v18.18.1-linux-x64.tar.xz <span class="hljs-comment">#-J 指定xz压缩格式（必须大写J）-x 解压操作 -f 指定要解压的文件</span><br><span class="hljs-comment">#or</span><br>tar --xz -xf node-v18.18.1-linux-x64.tar.xz<span class="hljs-comment">#我觉得这个更好记，就是不够优雅</span><br></code></pre></td></tr></table></figure><p>解压之后就得到了Node.js的二进制可执行文件了，这就相当于windows下的portable版本的软件，解压即用，不用注册表等信息。</p><p>如果是Windows下载下来应该是一个.exe的安装程序，就按照软件的正常安装步骤来就好。</p><p>现在进入bin文件夹下就可以看到npm包管理软件的可执行文件了，接下来将该路径添加到系统的环境变量中，这样在其他的路径下也可以直接通过软件名来调用npm等软件了。在bin文件夹中执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=<span class="hljs-subst">$(pwd)</span>:<span class="hljs-variable">$PATH</span>&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-comment">#or</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=[your-nodejs-bin-path]:<span class="hljs-variable">$PATH</span>&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>然后加载一下bash配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>这样就将该路径添加到了环境变量中了，下面安装Hexo。</p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="-3- 安装Hexo"></a>-3- 安装Hexo</h2><p>Hexo是一个快速、简洁且高效的博客框架。hexo就相当于一个毛坯房，我们只需要装修就行了，不需要再打地基从平地起楼房。</p><p>为什么选择Hexo框架而不是其他框架呢？对我来说，主要有以下几个优势：</p><ul><li>简单。hexo可以一键部署，命令简单，不需要复杂的操作，而且有中文的文档，最适合我这种纯小白了</li><li>支持Markdown。Markdown太好用了，YYDS，谁用谁知道</li><li>有许多的主题。颜值即正义，谁不想用好看的皮肤呢，自己写不出来，就直接clone大佬的主题，改个配置文件直接用，美滋滋</li></ul><p><a href="https://hexo.io/zh-cn/index.html">Hexo官网</a></p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230241456.png"></p><p>执行如下命令安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g <span class="hljs-comment">#-g 全局安装  </span><br></code></pre></td></tr></table></figure><blockquote><p>hexo-cli中的cli是指command line interface版本，即命令行接口版本</p></blockquote><p>可以通过<code>hexo -v</code>命令来判断是否安装成功，如果看到了版本号就是安装成功</p><hr><p>PS：这里可能会有人安装失败，因为国内复杂的网络环境以及众所周知的GreatWall，如果你的网络无法反复连接到npm服务器，就很可能导致安装失败，可以尝试使用国内镜像的cnpm（请自行搜索使用）。</p><p>OK，到这里搭建的环境就准备好了，下面就可以开始搭建工作了</p><h1 id="0x02-操作步骤"><a href="#0x02-操作步骤" class="headerlink" title="0x02 操作步骤"></a>0x02 操作步骤</h1><h2 id="1-初始化文件夹"><a href="#1-初始化文件夹" class="headerlink" title="-1- 初始化文件夹"></a>-1- 初始化文件夹</h2><p>首先创建一个空文件夹，用于存放blog的文件，然后进入该文件夹中，用<code>hexo init</code>初始化文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>hexo init<br></code></pre></td></tr></table></figure><p>此时，hexo会自动clone框架代码，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.landscape.yml<span class="hljs-comment">#主题landscape的配置文件</span><br>├── _config.yml<span class="hljs-comment">#整个网页的配置文件</span><br>├── node_modules<br>├── package.json<br>├── package-lock.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><span class="hljs-comment">#用于存放网页的源文件</span><br>└── themes<span class="hljs-comment">#用于存放主题的源文件</span><br></code></pre></td></tr></table></figure><h2 id="2-配置网页"><a href="#2-配置网页" class="headerlink" title="-2- 配置网页"></a>-2- 配置网页</h2><p>在根目录下有一个_config.yml 文件，它描述了整个hexo博客框架的配置。我们可以在这个文件里修改网页的标题和副标题、是否开启代码高亮功能等等，具体的配置可以根据<a href="https://hexo.io/zh-cn/docs/configuration.html">hexo官方文档</a>，但是这里有一个url配置项很重要，留到后面再说。</p><h2 id="3-预览网页"><a href="#3-预览网页" class="headerlink" title="-3- 预览网页"></a>-3- 预览网页</h2><p>其实初始化后，我们就已经获得了一个博客页面。使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br><span class="hljs-comment">#or</span><br>hexo s<span class="hljs-comment">#hexo可以自动补全</span><br></code></pre></td></tr></table></figure><p>就可以在本地预览默认的博客样式，按Ctrl+C退出。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230309151.png"></p><p>使用<code>hexo cl</code>可以清除掉hexo生成的静态网页，清除之后通过<code>hexo g</code>可以重新生成网页。</p><p>hexo的命令并不多，使用<code>hexo help</code>可以看到hexo的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">clean     Remove generated files and cache.                                   <br>config    Get or <span class="hljs-built_in">set</span> configurations.                                          <br>deploy    Deploy your website.                                                <br>generate  Generate static files.<br><span class="hljs-built_in">help</span>      Get <span class="hljs-built_in">help</span> on a <span class="hljs-built_in">command</span>.<br>init      Create a new Hexo folder.<br>list      List the information of the site<br>migrate   Migrate your site from other system to Hexo.<br>new       Create a new post.<br>publish   Moves a draft post from _drafts to _posts folder.<br>render    Render files with renderer plugins.<br>server    Start the server.<br>version   Display version information.<br></code></pre></td></tr></table></figure><h2 id="4-部署网页"><a href="#4-部署网页" class="headerlink" title="-4- 部署网页"></a>-4- 部署网页</h2><p>现在我们已经获得了一个网页，但是还是只能在本地浏览，如何将其放到github中呢？这时就需要编辑配置文件了。</p><p>打开博客根目录下的 _config.yml 文件，找到deploy项，按如下格式修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span> <br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">your-git-link</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">your-pages-branch</span><br></code></pre></td></tr></table></figure><p>其中</p><ol><li>type选择git</li><li>repo是指你github上的博客仓库链接</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230332444.png"></p><p>这里如果选择SSH链接，需要提前生成ssh id_rsa的公钥，并且添加到github上，如果没有添加的话就请STFW吧</p><p>由于github改版，如果选择HTTP链接，现在已经不能直接通过帐号密码访问到仓库了，必须要生成一个token，通过token做密码才能访问到仓库，而这个token只会在生成时以明文的形式显示一次，并且很难记。所以这里最推荐的是配置公钥后使用SSH，如果非要使用HTTPS链接，又不想每次都输入密码，这里也有一个曲线救国的方法，就是开启git的记住密码功能，这样只用输入一次之后就可以不用输入了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#开启git全局记住密码</span><br>git config --global credential.helper store<br></code></pre></td></tr></table></figure><ol start="3"><li>branch是指你想要将git提交到哪个分支上。这里我推荐仓库创建两个分支，一个pages用于存放静态网页资源，一个source用于存放整个blog的源文件。这里的配置应该选择用于存放网页资源的pages分支。所以我的配置如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span> <br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:GoooForward/blog.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">pages</span><br></code></pre></td></tr></table></figure><hr><p>修改好配置文件后保存退出，使用<code>hexo d</code>将网页资源push到仓库上时会发现报错了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tangyuwei@legion:~/blog$ hexo d<br>INFO  Validating config<br>ERROR Deployer not found: git<br></code></pre></td></tr></table></figure><p>这是因为我们选择了git来部署页面，而hexo此时还不知道git是什么，因此要安装一个插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br>#<span class="hljs-comment">--save 是指将插件安装到项目的node_modules目录下，并且写入依赖</span><br></code></pre></td></tr></table></figure><p>安装好插件之后再执行<code>hexo d</code>就能成功将网页资源push到仓库的对应分支了</p><hr><p>然后，来到github的对应仓库页面，选择Settings -&gt; Pages -&gt; Branch -&gt; 选择分支 -&gt; Save。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230600315.png"></p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230611572.png"></p><p>保存后，Github就会开始部署该分支上的网页了，这个过程需要一段时间，可以在Actions页面看到部署进度</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230637169.png"></p><p>成功部署之后就可以回到之前的pages页面访问你的Blog了</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/image-20231018230657411.png"></p><h3 id="踩坑一"><a href="#踩坑一" class="headerlink" title="踩坑一"></a>踩坑一</h3><p>当你兴致勃勃的打开你的博客页面时，大概率要失望了，因为你会发现页面的排版是乱的，并且图片资源加载不出来，但是文字的链接还是在的。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310191626076.png"></p><p>这就是我踩到的第一个坑了，当时一直搞不清楚是什么原因导致的。使用<code>hexo s</code>在本地预览是正常的，但是部署到github上就会出现排版混乱。使用firefox的F12开发者工具查看网络请求，可以看到资源都没有找到</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310191636116.png"></p><hr><p>经过一番search，终于找到了症结所在。回到本地的blog目录，编辑博客配置文件_config.yml，找到url的配置项，根据注释可以看到我们需要将github的博客页面的网址配置给url（注：url：后面有一个空格），还需要新增根目录项root并配置，其值为<code>/仓库名/</code>，其中前后的斜杠 &#x2F; 不能省。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310191706912.png"></p><p>编辑好配置文件之后，重新执行重新生成一次网页资源并部署，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl<span class="hljs-comment">#清除项目</span><br>hexo g<span class="hljs-comment">#重新生成项目</span><br>hexo d<span class="hljs-comment">#部署项目</span><br></code></pre></td></tr></table></figure><p>执行后等待github重新部署网页完成，此时再打开博客网页就会发现和之前预览的页面是一样的了。</p><p>其实_config.yml中还有很多和页面相关的配置，包括代码高亮，页面名称等等，可以自行根据官方文档进行配置。</p><h1 id="0x03-主题美化"><a href="#0x03-主题美化" class="headerlink" title="0x03 主题美化"></a>0x03 主题美化</h1><p>虽然hexo自带的landspace主题也还不错，但是还是缺少一些个性。hexo的一大优势就是支持更换主题，我们可以直接在github上clone大佬的开源主题，然后部署到我们自己的博客上，前人栽树，后人乘凉啊。</p><h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="-1- 下载主题"></a>-1- 下载主题</h2><p>Hexo有一个官方的<a href="https://hexo.io/themes/">主题站</a>，里面收录了很多的优质主题，这些主题提供了预览页面和github仓库主页，这里也推荐三个比较喜欢的主题</p><ul><li><a href="https://github.com/theme-next/hexo-theme-next">NexT</a>  <a href="https://theme-next.js.org/">预览</a></li></ul><p>​这可能是最出名的hexo主题之一了，在github有高达8k的star。它的功能很强大，还有很多开发者为其开发了插件，如果不知道选什么主题，用NexT肯定不会是一个错误的选择</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310201545466.png" alt="image-20231020154556334"></p><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> <a href="https://hexo.fluid-dev.com/">预览</a></li></ul><p>​一款国人大佬开发的hexo主题，也是我现在使用的主题。这款主题在github上也有6.4K的star，这款主题对国人很友好，不光文档是中文的，连配置文件里的注释都用中文写好了</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310201546103.png"></p><ul><li><a href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a> <a href="https://arknights.theme.hexo.yue.zone/">预览</a></li></ul><p>​老博士应该懂的都懂，有一说一，鹰角的UI设计的确是一流的</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310201550671.png"></p><p>下载主题就直接将主题源文件clone到博客仓库下的themes文件夹，或者下载release的文件，将其解压到themes文件夹中。这里有一个点要注意，也是我踩的第二个坑</p><h3 id="踩坑二"><a href="#踩坑二" class="headerlink" title="踩坑二"></a>踩坑二</h3><p>大多数的主题仓库名都是 <code>hexo-theme-主题名</code>，直接clone下来会自动创建一个以仓库名命名的文件夹，这里一定要看主题的文档，大部分的主题都会要求将这个文件夹重命名为主题名，或者直接在克隆时就给出目标文件夹，例如Arknights主题，其clone命令是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/Yue-plus/hexo-theme-arknights.git themes/arknights<br></code></pre></td></tr></table></figure><p>当时我就是因为看文档不仔细，忽略了clone命令最后的目标文件夹参数，导致下载的主题死活不生效，留下了粗心大意的泪水。</p><h2 id="2-配置主题"><a href="#2-配置主题" class="headerlink" title="-2- 配置主题"></a>-2- 配置主题</h2><p>这部分的配置主要根据主题的文档来进行配置，不同的主题的配置项差异很大，这里需要注意的是要区分 <strong>主题的配置文件</strong> 和 <strong>hexo网页框架的配置文件</strong>，它们的名称都是_config.yml，在根目录下的是hexo网页的配置文件，在主题文件夹下的是主题的配置文件。在Hexo 5.0.0 版本以上，主题配置会优先使用博客目录下的<code>_config.主题名.yml</code> 文件。</p><p>使用<code>hexo version</code>可以查看hexo版本</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310250940950.png"></p><p>主题配置完成之后，还要回到hexo网页的配置文件中修改theme的配置项</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310250944880.png"></p><p>都配置好后就可以重新生成、预览、部署了，当然，最好先清除一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl<br>hexo g<br>hexo s<br>hexo d<br></code></pre></td></tr></table></figure><p>至此，大致的配置就完成了，就可以打开你的博客网页查看效果了。</p><h1 id="0x04-使用方法"><a href="#0x04-使用方法" class="headerlink" title="0x04 使用方法"></a>0x04 使用方法</h1><h2 id="1-管理博文"><a href="#1-管理博文" class="headerlink" title="-1- 管理博文"></a>-1- 管理博文</h2><p>hexo 的博文的源格式是.md，其文件位置在&#x2F;source&#x2F;_posts&#x2F;下，你可以通过在这里新建md文件的形式来创建博文，也可以使用hexo的命令来新建博文，命令是</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">your_title</span><span class="hljs-meta">#注：title不包含.md后缀</span><br></code></pre></td></tr></table></figure><p>使用该命令后就会在&#x2F;source&#x2F;_posts&#x2F;下创建一个your_title.md的文件，之后就可以在该文件内开始创作了</p><p>同理，如果你想删除一篇博文，也只需要来到该文件夹下，删除该博文的md文件 或者 仅仅是把该博文的md文件移走即可</p><h2 id="2-源文件同步"><a href="#2-源文件同步" class="headerlink" title="-2- 源文件同步"></a>-2- 源文件同步</h2><p>此前我们使用<code>hexo d</code>只会将网页的静态资源上传到github上，也就是source文件夹下的那些文件，但是如果你想对网页进行一些修改，缺少源文件是做不到的。为了在不同的电脑上都可以对网页作出修改，我们需要将源文件同步。</p><p>还记得前面在部署时推荐创建两个分支吗，其中的source分支就是用来存储我们的源文件的。</p><ul><li><p>处理主题文件夹</p><p>如果主题文件夹是通过git clone的方式下载下来的话，在主题的文件夹里会有一个.git的隐藏文件夹，我们需要删除该文件夹，或者将其改为其他名称，我将其重命名为_git。这是因为通过git clone方式下载的文件夹会被视为一个git仓库，在我们暂存整个博客根目录时，git会检测到仓库的嵌套，会自动忽略被嵌套的子仓库，导致最终上传的github的源文件中缺少了主题的源文件，这样的话，我们在其他的机器上clone源文件就获取不到完整的代码，还需要重新clone一次主题的源文件，这显然是更麻烦的，还可能会导致你的主题配置文件丢失。因此，我们通过改名或删除.git文件夹的方式来避免git将主题文件夹识别为一个git仓库。</p></li><li><p>初始化根目录</p><p>来到博客的根目录，使用<code>git init</code>将该文件夹初始化为一个git仓库，然后使用<code>git add .</code>将所以文件暂存，然后使用<code>git commit</code>生成一笔提交。</p></li><li><p>添加远程服务器</p><p>使用<code>git remote add origin [url]</code> 添加新的远程，其命名为origin（可以改），其url就是仓库的地址，ssh和http均可。</p><p>然后pull同步一下，使用<code>git pull origin source --rebase</code> ,其中source是用于存放源文件的分支名，–rebase是指用rebase的方式处理冲突。</p></li><li><p>推送到远程服务器</p><p>使用命令<code>git push origin HEAD:source</code>来推送到远程服务器的source分支。</p></li></ul><p>成功之后就能在source分支中看到博客源文件了。</p><p><img src="https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note-image/202310251113339.png"></p><blockquote><p>这里需要注意的一点是，由于使用github部署网页必须使用公共仓库，因此将源代码推送到公共仓库的source分支后就意味着你的博客完全开源了，对于部分主题的博客上锁功能就失去意义了，如果你希望你的博客不完全开源的话，可以新建一个私有仓库，在添加远程服务器者一步中，将url替换为你的私有仓库的地址，就可以将代码推送到私有仓库了。</p><p>其实也可以使用子模块等其他办法，我觉得更麻烦，就不推荐了。</p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h1>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
