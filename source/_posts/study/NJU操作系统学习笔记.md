---
lstitle: NJU操作系统学习笔记
date: 2024-01-03 10:59:00
updated: {{ date }}
#hide: true
tags: 
categories: 学习
---



# 0x00 学习资料

[操作系统：设计与实现 ](https://jyywiki.cn/OS/2022/index.html)



# 0x03 多处理器编程

本节课主要内容：

* 什么是并发，如何用状态机去理解并发

* 在并发的情况下，用传统程序的方法去编写代码会带来哪些问题。

## -1- 并发

* 操作系统本身就是并发的程序，现代处理器大部分都是多处理器
* 并发的基本单位是线程，线程之间共享内存，每个线程都有自己的堆栈和寄存器，其中最重要的就是每个线程都拥有一个PC指针，用来指示当前程序的执行位置。要站在状态机的视角来看，单处理器情况下，系统每次会选择一个线程执行一步，而这个顺序是随机的，因此对于并发程序的行为是难以预测的（不同的线程都可以访问公共的全局变量，因此一个线程可以影响另一个线程的状态）。而在多处理器情况下，两个线程可能根本就是在不同的处理器核心上运行的，这就导致可能一个线程刚刚给一个全局变量赋值完成，在下一瞬间就可能被另外一个处理器上的线程修改掉。因此，并发使得程序失去了对当前状态的控制，一切都变得不可预测了。

![](https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note_image/image-20240103221638547.png)

* 不同的线程之间的堆栈是独立的（[stack-probe.c](https://jyywiki.cn/pages/OS/2022/demos/stack-probe.c)），但是全局变量是共享的（[shm-test.c](https://jyywiki.cn/pages/OS/2022/demos/shm-test.c)）。

  

## -2- 原子性丧失

原子性是指一段代码的执行独占整个计算机，也就是程序的执行不会被打断。

这在单核处理器上，会被中断打断。在多核处理器上根本就是并行的。

原子性的丧失会导致很多问题，当两个线程同时写一个变量时，由于原子性的丧失，线程无法保证写完成之后，该变量就变成了刚刚写入的值，因为可能在写入完成的下一瞬间，就被其他的线程写入了其他值



## -3- 顺序性丧失

编译器对C程序的优化的前提，是假设程序是单线程的。编译器首先假定程序是顺序执行的，它只保证最终写入内存的值是和程序员所写的代码是一致的即可，也就是当有连续的三个x+1时，编译器会认为x+3，编译器只保证最终写入内存的值是x+3，而不保证之间的过程。这在单线程情况是没有问题的，而在多线程情况就可能出现问题了。

```
#include "thread.h"

#define N 100000000

long sum = 0;

void Tsum() {
  for (int i = 0; i < N; i++) {
    sum++;
  }
}

int main() {
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}
```

给 [sum.c](https://jyywiki.cn/pages/OS/2022/demos/sum.c) 添加编译优化

- `-O1`: 100000000 😱😱
- `-O2`: 200000000 😱😱😱

在不同的编译等级下，sum++会被翻译为不同的结果。程序的本意是希望sum一步一步的逐次加1，而编译器的优化使得程序在多线程情况下出错了

- `-O1`: `R[eax] = sum; R[eax] += N; sum = R[eax]`

  -T1执行取出sum给寄存器，值0

  -T2执行取出sum给寄存器，值0

  -T1执行寄存器+N，值N

  -T2执行寄存器+N，值N

  -T1执行将寄存器赋值给sum，值N

  -T2执行将寄存器赋值给sum，值N

  可见，sum的值被赋值了两次，并且都是N，所以最终的结果是100000000

- `-O2`: `sum += N;`

  O2情况下，虽然被编译成了一个指令，使得结果看上去貌似是正确的，但是依然与我们程序所希望的不同。

因此，在多线程编程时要注意编译器优化，所有的希望程序一定要去读内存的地方，都要想办法防止编译器优化，否则编译器可能就会帮你偷懒。

> `asm volatile ("" ::: "memory");` compiler barrier
>
> 使用volatile 变量保持 C 语义和汇编语义一致

## -4- 多处理器间即时可见性的丧失

由于现代处理器本身也是一个编译器，处理器会将汇编指令再拆分成为微指令，然后维护一个指令池，然后向这个指令池里尽可能多地发射指令来提高效率。其原则是乱序执行，按序提交。这个特性导致了即使是按序的汇编指令也可能被乱序执行。因为这个cpu的特性也只保证单线程的内存最终一致性。



# 0x04 理解并发程序执行

本节课的主要内容：

* 什么是互斥

* 使用算法来实现互斥
* 如何用状态机来检查一个互斥算法是否正确



# 0x05 并发控制：互斥

半节课的主要内容：

* 自旋锁的原理和实现
* 互斥锁的原理和实现
* Futex

## -1- 共享内存上的互斥

实现互斥的根本困难：**不能在一个原子操作中同时实现read&write**



## -2- 自旋锁

为了实现互斥有两种思路：一种使用不同的互斥算法来解决问题，而另一种就是改造硬件，让硬件提供一个可以瞬间完成读写的指令。

而现代的处理器都提供了这样的可以同时完成读写操作的指令，也就是原子操作。

**Atomic exchange (load + store)**

```C
int xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}
```

这个lock的指令前缀就是汇编代码中原子指令的前缀。



有了这条指令之后，想要实现锁来保护线程就很容易了

![](https://gcore.jsdelivr.net/gh/GoooForward/picture@main/note_image/image-20240122212714200.png)

​	一个自旋锁的实现：

```c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES)
}
```

```c
int locked = 0;
void lock() { while (xchg(&locked, 1)) ; }
void unlock() { xchg(&locked, 0); }
```

自旋锁的本质就是一个公共变量，成功获得这个变量的线程有运行下去。而实现这个锁的前提条件就是成功实现原子的xchg指令，这条指令保证了不可能同时有两个线程同时获得这个资源。



* 自旋锁的优势在于它的实现足够简单，不需要操作系统的参与，不需要陷入内核
* 自旋锁的劣势在于它的本质其实是一致循环去判断是否获得了锁，在某个线程长时间占据某个锁的时候，其他的锁还是在不断的判断，这就会造成cpu很大浪费

![](/home/tangyuwei/.config/Typora/typora-user-images/image-20240122214236170.png)



## -3- 互斥锁

互斥锁借助了操作系统的调度，实现了长临界区。操作系统实现了两个系统调用

- ```
  syscall(SYSCALL_lock, &lk);
  ```

  - 试图获得 `lk`，但如果失败，就切换到其他线程

- ```
  syscall(SYSCALL_unlock, &lk);
  ```

  - 释放 `lk`，如果有等待锁的线程就唤醒

借助系统调用，可以避免自旋锁的空转问题。而操作系统自身借助自旋锁，保证自身是调度过程是原子的



## -4- Futex

futex是结合了自旋锁和互斥锁各自的优势的一种锁

![](/home/tangyuwei/.config/Typora/typora-user-images/image-20240122215139630.png)



# 0x13 系统调用和Shell

